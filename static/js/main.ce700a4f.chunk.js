(this["webpackJsonpmy-app"]=this["webpackJsonpmy-app"]||[]).push([[0],{31:function(e,t,s){},32:function(e,t,s){},39:function(e,t,s){"use strict";s.r(t);var i,n=s(24),o=(s(30),s(31),s(6)),a=s(7),r=s(9),c=s(8),d=s(2),l=s(12),u=s(11),m=s(58),p=(s(32),s.p+"static/media/processor-icon.53ff0c0c.svg"),h=s(56),g=s(57),f=[{id:"data",name:".data",usage:".data addr",description:"Store subsequent items in the data segment",arguments:"addr (optional):  the address to store subsequent items at",effect:"Subsqeuent items are stored in the data segment.",notes:"By convention, simple MIPS programs begin with a data segment, so this directive is often the first line of a file. Data segments holds items with program-level lifetimes (i.e. they are accessable for the entire life of the program)."},{id:"text",name:".text",usage:".text addr",description:"Store subsequent items in the text segment",arguments:"addr (optional):  the address to store subsequent items at",effect:"Subsqeuent items are stored in the text segment.",notes:"By convention, simple MIPS programs place a text segment after the data segment, so this directive often comes at the end of the data segment. Text segments hold instructions; more complex code may store other kinds of data within text segments, but this is less common."},{id:"kdata",name:".kdata",usage:".kdata addr",description:"Store subsequent items in the kernel data segment",arguments:"addr (optional):  the address to store subsequent items at",effect:"Subsqeuent items are stored in the kernel data segment."},{id:"ktext",name:".ktext",usage:".ktext addr",description:"Store subsequent items in the kernel text segment",arguments:"addr (optional):  the address to store subsequent items at",effect:"Subsqeuent items are stored in the kernel text segment."},{id:"align",name:".align",usage:".align n",description:"Align the next item to a 2^n byte boundary.",arguments:"n: log2(boundary)",effect:"The next item is aligned to a 2^n byte boundary",notes:"To word align an item (e.g. an array which you will access with lw), use .align 2."},{id:"ascii",name:".ascii",usage:'.ascii "str"',description:"Store an ascii encoded string in memory",arguments:"str: the string to store in memory",effect:"The string is ascii encoded and stored in the current segment.",notes:"Since most functions/syscalls expect null-terminated strings, this directive should be used with caution. Typically, this directive is preceded by a label so the string can be referenced conveniently."},{id:"asciiz",name:".asciiz",usage:'.asciiz "str"',description:"Store an ascii encoded string in memory (null terminated)",arguments:"str: the string to store in memory",effect:"The string is ascii encoded, null terminated, and stored in the current segment.",notes:"Typically, this directive is preceded by a label so the string can be referenced conveniently."},{id:"byte",name:".byte",usage:".byte b1, ..., bn",description:"Store n bytes in memory",arguments:"b1, ..., bn: the bytes to store in memory",effect:"The bytes are stored in the current segment.",notes:"Typically, this directive is preceded by a label so the bytes can be referenced conveniently."},{id:"half",name:".half",usage:".half h1, ..., hn",description:"Store n half-words in memory",arguments:"h1, ..., hn: the half-words to store in memory",effect:"The half-words are stored in the current segment.",notes:"Typically, this directive is preceded by a label so the half-words can be referenced conveniently."},{id:"word",name:".word",usage:".word w1, ..., wn",description:"Store n words in memory",arguments:"w1, ..., wn: the words to store in memory",effect:"The words are stored in the current segment.",notes:"Typically, this directive is preceded by a label so the words can be referenced conveniently."},{id:"float",name:".float",usage:".float f1, ..., fn",description:"Store n floats in memory",arguments:"f1, ..., fn: the floats to store in memory",effect:"The floats are stored in the current segment.",notes:"Typically, this directive is preceded by a label so the floats can be referenced conveniently."},{id:"double",name:".double",usage:".double d1, ..., dn",description:"Store n doubles in memory",arguments:"d1, ..., dn: the doubles to store in memory",effect:"The doubles are stored in the current segment.",notes:"Typically, this directive is preceded by a label so the doubles can be referenced conveniently."},{id:"space",name:".space",usage:".space n",description:"Allocates n bytes of space in the current segment",arguments:"n: the number of bytes to allocate in memory",effect:"The bytes are reserved in the current segment.",notes:"Typically, this directive is preceded by a label so the space can be referenced conveniently. The space can be used for any kind of data - it is up to you to keep track of its purpose. For example, .space 40 could be declared for an array of 10 integers, or a 39-character string with a null-terminator."},{id:"extern",name:".extern",usage:".extern sym size",description:"Declare that the item at sym with the specified size is a global label",arguments:"sym: the item to declare as global; size: the size of the item",effect:"The specified item is stored in a position which can be accessed quickly using $gp"},{id:"globl",name:".globl",usage:".globl label",description:"Declare that the specified label can be accessed from other files",arguments:"label: the label to make accessable form other files",effect:"The specified label will be accessable form other files"},{id:"set",name:".set",usage:".set arg",description:"Disable or re-enable warnings about the use of $at for subsequent lines",arguments:"arg: 'noat' to disable warnings, 'at' to enable warnings",effect:"Warnings will be enabled/disabled for subsequent lines",notes:"Since the assembler uses $at when expanding pseudoinstructions, care must be taken to ensure that values placed in $at are not overwritten"}],y=[{id:"basics",name:"Basics",description:"Getting started with MIPS assembly and QtSpim",items:[{type:"heading",text:"What's QtSpim?"},{type:"paragraph",text:"QtSpim provides two major features for testing your MIPS assembly language code. First, QtSpim includes an assembler, which turns your assembly code into its binary equivalent (machine code). Second, QtSpim includes a simulator of a MIPS processor which allows you to test your code. When you write code in other languages, like c, a compiler can convert your code into machine code that you can test by running it directly on your computer's processor. When you write MIPS assembly, the code is specifically designed to run on a MIPS processor, which your computer does not have, so you need a simulator to test it."},{type:"heading",text:"MIPS Processor Basics"},{type:"paragraph",text:"Before you start learning to write MIPS assembly code, its important to understand some basic principles of how MIPS processors work. First, the MIPS processor uses a RISC (reduced instruction set computer) design. This means that it can perform a (relatively) small number of simple instructions, and more complex operations will require multiple instructions. Second, instructions in the MIPS architecture mostly fall into three categories: arithmetic/logical operations, memory operations, and branch/jump operations. Third, since arithmetic/logical operations are separate from memory operations, the processor uses a small set of special memory units in the processor called registers. All arithmetic & logical operations work on data stored in these registers. If you need to change a value in memory, it will require (at least) three instructions: one to load the current value from memory into a register, one to change the value, and one to store the value back to memory. The MIPS processor has 32 registers. They are referred to by a $ followed by a number (i.e., $0 - $31). Some registers have special purposes, many relating to writing procedures. To help remember the registers' purposes, they are usually referred to them by friendly names that start with a letter (e.g., $t2). You can see all the registers on the Registers page, but if you're just getting started it's safe to use the ones that start with a letter 's' (i.e., $s0 - $s7) or 't' (i.e., $t0 - $t9)."},{type:"heading",text:"Creating a MIPS assembly file"},{type:"paragraph",text:"MIPS assembly is written as plain text. You can use a text editor like Visual Studio Code, Kate, or Sublime to write you code. Your file should use a .s or .asm extension so that QtSpim and your text editor recognize it as as assembly language file."},{type:"heading",text:"A Simple MIPS Assembly Program"},{type:"paragraph",text:"One of the functions the MIPS assembler performs is splitting up your code (referred to as text) from your variables (referred to as data) in memory. When you write MIPS assembly code, you need to tell the assembler whether the upcoming lines will be data or code declarations. This is done using an assembler directive; in MIPS assembly, assembler directives start with a period ('.'). You can see more assembler directives on the Assembler Directives page, but to get started, use a .text directive to let the assembler know you'll be writing code:"},{type:"code",text:".text"},{type:"paragraph",text:"Once you've added a .text declaration, you'll need to let the assembler know where your program starts. In your program, you use labels to mark the location of a block of code or memory; labels end with a colon (':'). To let the assembler know where your program starts, use a label called main:"},{type:"code",text:"main:"},{type:"paragraph",text:"Once you've added the main label, you can start adding instructions. You can view most of the instructions supported by QtSpim on the Instructions page. Normally, you should write one instruction on each line of your file. You can use indentation to help organize your code if you'd like, but remember it does not have any special meaning to QtSpim."},{type:"paragraph",text:"Instructions in MIPS assembly include a short mnemonic (typically just a few letters) that identifies what the processor should do, followed by some arguments. The arguments are mostly registers, but sometimes a constant value or label. To get started, you can initialize a register to a specific value using the load immediate ('li') instruction:"},{type:"code",text:"li $t0, 3 # $t0 holds constant 3;li $t1, 6 # $t1 holds constant 6"},{type:"paragraph",text:"Notice that the arguments (e.g., $t0 and 0) are separated by a comma, but there is no comma after the instruction name. You can also see these lines include comments using a pound sign ('#'). It's a good idea to use a comment on the first line that uses a register saying what the what your program will use the register for. You can't name the registers, so this is the best way to keep track of what each register holds."},{type:"paragraph",text:"Once you've placed values into some of the registers, you can start to perform arithmetic operations on the values. For example, the following instruction adds the values in registers $t0 and $t1, and places the result into register $t2:"},{type:"code",text:"add $t2, $t0, $t1 # $t2 holds the sum"},{type:"paragraph",text:"For most MIPS assembly instructions, the destination register (where the result is stored) comes first, followed by the source register(s) (where the operands come from). So the add instruction above reads the current values in $t0 and $t1, adds the values, and places the result in $t2. If you aren't sure what order to put the arguments in for a specific instruction, it's always a good idea to check the Instructions page for information on how to use all the instructions. The page is also searchable by tags and descriptions, so if you know what you want to do but you aren't sure what the instruction is called, it's a good place to search."},{type:"paragraph",text:"Once you've calculated some kind of result, you may want to display it to the user. This is done using the console provided by QtSpim. To do input or output using the console in QtSpim, you'll use a syscall (short for system call). This is a special kind of instruction that asks the system to do something. Unlink other instructions where all the arguments are specified in one line of code, the syscall instruction doesn't take any arguments at all. You need to use special registers to communicate what you would like the system to do. First, you place a special value into the register $v0 which tells the system what type of operation you are requesting. You can look up this value on the Syscall page. In this case, you want to print an integer to the console, so the value (sometimes called a syscall code or syscall number) is 1. You can use load immediate to put a value of 1 in $v0:"},{type:"code",text:"li $v0, 0 # Syscall code for print int"},{type:"paragraph",text:"The other piece of information you can get from the Syscall reference is what arguments a syscall uses. For printing an integer, there is a single argument (the value to print), and it needs to be placed in register $a0. Since the sum you calculated earlier is stored in $t2, you can use a move instruction to copy the sum into $a0:"},{type:"code",text:"move $a0, $t2 # value to print"},{type:"paragraph",text:"Note that the move instruction doesn't actually change the value in the original register, so it is better to think of it as a copy operation. Finally, once you have the syscall code and arguments set up, you can do the syscall using the syscall instruction:"},{type:"code",text:"syscall"},{type:"paragraph",text:"So the complete program to add two values and print the sum to the console looks like this:"},{type:"code",text:".text;;main:;    li $t0, 3           # $t0 holds constant 3;    li $t1, 6           # $t1 holds constant 6;;    add $t2, $t0, $t1   # $t2 holds the sum;;    li $v0, 1           # Syscall code for print int;    move $a0, $t2       # value to print;    syscall"},{type:"paragraph",text:"To run the program in QtSpim, you can copy it into a text file and save it with a .s extension. Then, in QtSpim, use the Reinitialize and Load File button, select the file, and hit Run. If you want to run a program again or you've changed the code, use the Reinitialize and Load File button again. If you don't see any console window when you run the program, make sure Console is checked under the Window menu. "}]},{id:"control-flow",name:"Control Flow",description:"Branching & jumping, if & if-else blocks, and loops",items:[{type:"heading",text:"Control flow"},{type:"paragraph",text:"Control flow is the order in which your code gets run by the processor. In a language like c, you can use statements like if, for, and while to specify blocks of code to jump over or repeat. MIPS assembly language doesn't have these statements, so code is simply run line after line starting at the main: label and continuing until the end of the file is reached. If you need to do anything more complex, you need to use branch or jump instruction."},{type:"paragraph",text:"The simpler of the two is a jump instruction, which takes only a single argument, a label to jump to:"},{type:"code",text:"main:;    li $t0, 3;    j blockTwo;    li $t1, 2;blockTwo:;    li $t2, 5"},{type:"paragraph",text:"In the code block above, the jump instruction ('j') causes the processor to skip over the line which sets the value of $t1, go immediately to the label called 'blockTwo', and start executing from there. Of course this alone isn't particularly useful, so MIPS also includes branch instructions. Branch instructions work similarly to jump instructions except they only go to the specified label if a condition is true. There are different branch instructions for different conditions. For example, the branch equal instruction ('beq') only branches to the specified label if two registers are equal:"},{type:"code",text:"main:;    li $t0, 1;    li $t1, 5;    li $t2, 5;    beq $t0, $t1, blockOne;    beq $t1, $t2, blockTwo;    li $t3, 6;;blockOne:;    li $t4, 3;;blockTwo:;    li $t5, 4"},{type:"paragraph",text:"In the code block above, the first branch instruction doesn't do anything, because the values in $t0 and $t1 are not equal. The second branch instruction causes the processor to jump to the label blockTwo because the values in $t1 and $t2 are equal. If you ran this block of code, the values of $t0, $t1, $t2, and $t5 would be set; the values of $t3 and $t4 will not be affected because the instructions that reference them get skipped over. Again, this example isn't particularly useful. You'll see in the sections below how branch statements can be used to create code that works similarly to typical control flow constructs seen in higher level languages."},{type:"heading",text:"If Block"},{type:"paragraph",text:"The simplest control flow construct is an if block, a block of code that only runs if a specific condition is true. In a higher level language, that might look like this:"},{type:"code",text:"if (t0 >= t1) {;    t2 = 7;};t3 = 6;"},{type:"paragraph",text:"The equivalent code in MIPS:"},{type:"code",text:"    blt $t0, $t1, lessThan;    li $t2, 7;lessThan:;    li $t3, 6"},{type:"paragraph",text:"Due to the way MIPS assembly is laid out, the easiest way to write an if statement is usually to invert the condition. In this case, we only wanted to set the value of $t2 if $t0 is greater than or equal to $t1. To do so we used the branch less than instruction ('blt') to skip over the line that sets the value of $t2 if $t0 is less than $t1."},{type:"heading",text:"If-Else Block"},{type:"paragraph",text:"A slightly more complex example is an if-else block. In a higher level language, that might look like this:"},{type:"code",text:"if (t0 >= t1) {;    t2 = 7;};else {;   t3 = 6;};t4 = 10"},{type:"paragraph",text:"The equivalent code in MIPS:"},{type:"code",text:"    bge $t0, $t1 greaterThanOrEqual;    li $t3, 6;    j doneIfElse;greaterThanOrEqual:;    li $t2, 7;doneIfElse:;    li $t4, 10;"},{type:"paragraph",text:"Again, due to the way MIPS is laid out, things get flipped a bit. In this case, the 'else' part comes before the 'if' part. Also note that the first block must end with a jump statement that skips over the second block; otherwise both of the blocks would get executed."},{type:"heading",text:"For Loop"},{type:"paragraph",text:"A simple for loop in a higher level language might look like this:"},{type:"code",text:"for (t0 = 0, t0 < 10, t0++) {;    t2 = t2 + 4;}"},{type:"paragraph",text:"The equivalent code in MIPS:"},{type:"code",text:"    li $t0, 0               # $t0 will be the loop counter;    li $t1, 10              # $t1 will be the max value;;loop:;    bge $t0, $t1, exitLoop  # if the counter is greater than or equal to the max, exit the loop;    addi $t2, $t2, 4        # add 4 to $t2;    addi $t0, $t0, 1        # increment the loop counter;    b loop                  # run the loop again;;exitLoop:                   # if we get here, the loop is done;...;"},{type:"paragraph",text:"Writing a loop will require at least one label and one branch statement. In this case, it is written with two of each. If you know for sure that your loop should run at least once, it can be written with a single label at the top, and a conditional branch at the bottom that branches back to the label at the top if the loop needs to run again. If the loop might not even have to run once, the format shown here is needed because it checks the conditional at the top of the loop. If you forget the instruction that implements the loop counter (or otherwise construct a loop incorrectly), you might create an infinite loop. If you code has an infinite loop and you run it in QtSpim, QtSpim will likely freeze or crash. You might need to use force quit the program."},{type:"heading",text:"Nested For Loop"},{type:"paragraph",text:"A nested for loop that prints out the first ten multiples of the first ten positive integers in a higher level language might look like this:"},{type:"code",text:"for (t0 = 1, t0 <= 10, t0++) {;    for (t1 = 1, t1 <= 10, t1++) {;        print (t0 * t1);    };}"},{type:"paragraph",text:"The equivalent code in MIPS:"},{type:"code",text:"    li $t0, 1                           # $t0 is the outer loop counter;    li $t1, 1                           # $t1 is the inner loop counter;    li $t2, 10                          # $t2 is the max value;;outerLoop:;    bgt $t0, $t2, exitOuterLoop         # if counter > max, exit outer loop;    li $t1, 1                           # reset the inner loop counter every time the outer loop runs;innerLoop:;    bgt $t1, $t2, exitInnerLoop         # is counter > max, exit inner loop;    mul $a0, $t0, $t1                   # calculate the sum;    li $v0, 1                           # syscall code for print int;    syscall;    li $v0, 11                          # Syscall code for printing a character;    li, $a0, 32                         # ASCII value of space;    syscall;    addi $t1, $t1, 1                    # increment inner loop counter;    b innerLoop                         # do the inner loop again;exitInnerLoop:;    addi $t0, $t0, 1                    # increment outer loop counter;    b outerLoop                         # do the outer loop again;exitOuterLoop:"},{type:"paragraph",text:"With nested loops, be sure to leave clear comments for yourself and name your labels logically. Since you'll need multiple labels and counters, it's important to keep everything straight."}]},{id:"arrays",name:"Arrays",description:"Creating, reading, and editing arrays",items:[{type:"heading",text:"Allocating Arrays"},{type:"paragraph",text:"MIPS has no built-in concept of arrays, meaning they must be managed by the programmer from start to finish. The first step is to allocate space for the array, which should be done in a .data section:"},{type:"code",text:".data;...;myArray: .space 40"},{type:"paragraph",text:"The declaration has three parts. First, a label, which allows you to refer to the memory segment from your code. Second, the assembler directive .space, which tells the assembler to reserve bytes in the data segment. Finally, the number 40, which tells the assembler how many bytes to reserve. You might have noticed the declaration does not include a data type. In programming languages like c, the size of an array is automatically calculated by multiplying the number of items (length) by each item's size. In MIPS, you must do this manually. For example, integers in MIPS have a size of 4 bytes. Thus, an array of 10 integers requires 10 \xd7 4 = 40 bytes."},{type:"heading",text:"Accessing Array Elements"},{type:"paragraph",text:"Just like you must manually calculate the size of an array for allocation, you must manually calculate the location of items in an array to access them. Arrays store items one after another in memory, so to access a specific item you must first determine where the array begins in memory, then determine the item's offset within the array. Finding the memory address where an array starts can be done with the load address pseudoinstruction:"},{type:"code",text:"la $t0, myArray     # Store the base address in $t0"},{type:"paragraph",text:"The next step is to calculate the offset. As an example, lets access the item with index 3:"},{type:"code",text:"li $t1, 3           # Store the desired index in $t1"},{type:"paragraph",text:"To do this, multiply the index of the desired item by the size of the items in the array. In the case of an integer array, the size is 4 bytes, so you index must be multiplied by 4. The most obvious way to do this is using the mul pseudoinstruction:"},{type:"code",text:"li $t2, 4           # Store the size of an int;mul $t1, $t1, $t2   # Multiply the index by the size of an int"},{type:"paragraph",text:"You can do this more efficiently by using a shift. Multiplying by 4 in binary is similar to multiplying by 100 in decimal: it moves the decimal two places. MIPS lets you shift numbers with a single instruction; in this case we will shift two places to the left using shift left logical:"},{type:"code",text:"sll $t1, $t1, 2"},{type:"paragraph",text:"Whichever method you used to calculate the offset, you now need to add it to the base address of the array:"},{type:"code",text:"add $t1, $t0, $t1"},{type:"paragraph",text:"Finally we have the address of the item we want to access! The last step is to get the item's value. We can do this using a load command. Since integers are 4 bytes, we will use load word:"},{type:"code",text:"lw $t2, 0($t1)"},{type:"heading",text:"Editing Array Elements"},{type:"paragraph",text:"Editing array elements is very similar to accessing them. You must follow the same procedure to calculate the item's location. Assuming you followed the instructions in the previous section to calculate the item's address in $t1, you can use a store word instruction to change the value:"},{type:"code",text:"li $t3, 21          # We want to store 21 into the array;sw $t3, 0($t1)"},{type:"paragraph",text:"Putting the registers in the wrong order is a common mistake when using store word. When done correctly, the first register specified is the value to be stored, and the second register specified is the memory location where the item should be stored. This can seem backwards because most MIPS instructions list the destination register first (although technically speaking neither register is a destination because store word does not change the contents of either register)."},{type:"heading",text:"Looping Over Arrays"},{type:"paragraph",text:"Looping over arrays typically involves tracking a counter as well as a current position in memory. With every iteration of the loop, the counter must be increased by 1 and the position in memory must be increased by the size of the items in the array. Here is an example which tracks a count in $t0 and a memory position in $t1. It prints out a 10 item array of integers to the console:"},{type:"code",text:"li $t0, 0           # Initialize count to 0;la $t1, myArray     # Initialize memory position to start of the myArray;li $t2, 9           # Maximum index for a 10 item array;;loop:;lw $t3, 0($t1)      # Access the current item;li $v0, 1           # Syscall code for printing an int;move $a0, $t3       # Place the current item for Syscall;syscall;;addi $t0, $t0, 1    # Increment count;addi $t1, $t1, 4    # Increment memory position by 4 (size of an int);ble $t0, $t2, loop  # Loop again if the index is not greater than the maximum"}]},{id:"strings",name:"Strings",description:"Creating, reading, and printing strings",items:[{type:"heading",text:"Initialized Strings"},{type:"paragraph",text:"MIPS assembly allows you to create string which are initialized to a given value using the .ascii and .asciiz directives:"},{type:"code",text:'.data;...;myString: .asciiz "Hello world\\n"'},{type:"paragraph",text:"The .asciiz directive automatically adds a null terminator to the string (which is necessary for printing to the console), so in most cases it is preferred. The declaration has three parts. First, a label, which allows you to refer to the string from your code. Second, the assembler directive .asciiz, which tells the assembler to reserve bytes in the data segment and prefill them with the given string. Finally, a string to place in memory. The size is automatically calculated based on the length of the given string."},{type:"heading",text:"Printing Strings to the Console"},{type:"paragraph",text:"Strings can be printed to the console using a syscall:"},{type:"code",text:"li $v0, 4           # Syscall code for printing a string;la, $a0, myString   # Address of string to print;syscall"},{type:"paragraph",text:"The system keeps printing characters until it finds a null terminator, so strings must be null terminated for printing to the console. You might have noticed that the string in this example contains a new line character (the \\n); this is useful for keeping the console output readable."},{type:"heading",text:"Printing Newlines to the Console"},{type:"paragraph",text:"In the previous example a newline was added to the string to keep the output readable. Sometimes you need to print just a newline. While you can accomplish this by creating a string in the .data section containing only a newline, you can also use the print character syscall as a shortcut:"},{type:"code",text:"li $v0, 11          # Syscall code for printing a character;li, $a0, 10         # ASCII value of newline;syscall"},{type:"heading",text:"Reading Strings from the Console"},{type:"paragraph",text:"To read a string from the console, you must first allocate space for the string using the .space directive in the .data section:"},{type:"code",text:".data;...;inString: .space 10"},{type:"paragraph",text:"Note that you must allocate space for the null terminator. In this example, allocating 10 bytes will actually only allow 9 characters to be read from the console."},{type:"paragraph",text:"Next, you can read a string using a syscall:"},{type:"code",text:"li $v0, 8           # Syscall code for reading a string;la, $a0, inString   # Address to store the string at;li $a1, 10          # Length of string to read;syscall;"},{type:"paragraph",text:"The length specified is a maximum; the syscall will keep reading characters until you enter a newline (press enter) or it runs out of space. If you press enter before the maximum number of characters has been read, the newline character (ASCII value 10) will be included in the inputted string. Note that the length includes the null terminator. In this example, only 9 characters (at most) will be read from the console because we specified a length of 10."},{type:"heading",text:"Looping over Strings"},{type:"paragraph",text:"Looping over a string (character by character) can be accomplished using a register, which holds the address of the current character, and the lbu instruction, which will load a single byte from memory. You may see the lb instruction used in some examples, but lbu is preferred because characters are not signed values (although QtSpim only supports 7-bit ASCII characters so it technically does not matter either way). When you load a character into a register using lbu, the destination register will hold a number which is the ASCII value of the character. You can refer to an ASCII table to see which characters correspond to which values."},{type:"paragraph",text:"Here is a complete example program which reads a string from the user and loops over it to check if it contains the letter m:"},{type:"code",text:'.data;prompt: .asciiz "Enter a string (20 characters max): ";resultYes: .asciiz "The string contained the letter m";resultNo: .asciiz "The string did not contain the letter m";input: .space 21;;.text;main:;;li $v0, 4           # Syscall code for printing a string;la, $a0, prompt     # Address of string to print;syscall;;li $v0, 8           # Syscall code for reading a string;la, $a0, input      # Address to store the string at;li $a1, 21          # Length of string to read;syscall;;la $t0, input        # $t0 will hold current position in the string;li $t1, 109          # ASCII value of lower-case m;loop:;lbu $t2, 0($t0)      # Read a character from the string;beqz $t2, notFound   # If the character is a null terminator (zero), jump to notFound;beq $t2, $t1, found  # If the character is m, jump to found;addi $t0, $t0, 1     # Increment loop counter;b loop               # Did not find a null terminator or an m, so loop again;;notFound:;li $v0, 4           # Syscall code for printing a string;la, $a0, resultNo   # Address of string to print;syscall;;li $v0, 10          # Syscall code to terminate;syscall;;found:;li $v0, 4           # Syscall code for printing a string;la, $a0, resultYes  # Address of string to print;syscall;;li $v0, 10          # Syscall code to terminate;syscall'},{type:"paragraph",text:'Note: the address of the current character can be used as a "counter" when looping over a string. Each iteration of the loop should increment the counter by 1 (since characters are only 1 byte in ASCII). When the character read is a null terminator (ASCII value 0), the loop should stop.'}]},{id:"errors",name:"Errors",description:"Common QtSpim errors",items:[{type:"paragraph",text:"QtSpim error messages can be a bit terse. This guide includes frequent errors in QtSpim and tips for fixing the most common causes."},{type:"heading",text:"Syntax Error"},{type:"code",text:"spim: (parser) syntax error on line n of file /*/*.s    inst args"},{type:"paragraph",text:"This error message indicates that the line of code shown cannot be understood by QtSpim. Common causes include misspelled instruction names, typos in register names or other arguments, and missing commas. You may also see the error if you are using an instruction which is supported in other environments (e.g. MARS) but not in QtSpim."},{type:"heading",text:"Label is Defined for the Second Time"},{type:"code",text:"Error Message:;spim: (parser) Label is defined for the second time on line n of file /*/*.s    label:"},{type:"paragraph",text:'This error indicates a label has been defined twice. Double check that you have not used the same label name twice in your program. This error also occurs if you load a file twice in QtSpim without re-initializing; make sure you are using "Reinitialize and Load File" not "Load File".'},{type:"heading",text:"Instruction References Undefined Symbol"},{type:"code",text:"Error Message:;Instruction references undefined symbol at 0x00400014 [00400014] 0x0c000000  jal 0x00000000 [main]    : 188: jal main "},{type:"paragraph",text:"This error indicates your program has no main label. Try adding main: to the start of your .text segment."},{type:"code",text:"Error Message:;Instruction references undefined symbol at 0x-------- [--------] 0x--------  inst <args>    : ---: inst <args> "},{type:"paragraph",text:"This error indicates your program is trying to reference a label which is not defined. The most common cause is typos. If the instruction resulting in the error is la, lw, or sw, the corresponding label should be in the .data section. If the instruction resulting the error is a branch or jump, the corresponding label should be in the .text section."},{type:"heading",text:"Attempt to Execute Non-Instruction"},{type:"code",text:"Error Message:;Attempt to execute non-instruction at 0x--------"},{type:"paragraph",text:"This error message indicates that the program counter is not referencing a valid instruction. The most common cause is that your program does not end with a syscall for termination (syscall code 10). It could also be caused by calling jr $ra with an incorrect address in $ra."},{type:"heading",text:"Unaligned Address"},{type:"code",text:"Error Message:;Unaligned address in inst/data fetch: 0x--------"},{type:"paragraph",text:"This error message indicates that you are trying to access a memory address that is not aligned to the expected boundary for the current instruction. In most cases, this results from using lw or sw to access an item from the .data section. In the .data section, try adding .align 2 on the line above the item you are trying to access."},{type:"heading",text:"Bad Address"},{type:"code",text:"Error Message:;Bad address in data/stack read: 0x--------"},{type:"paragraph",text:'This error message indicates that you are trying to access a memory address that is available to be read/written. In most cases, this results from using a load or store instruction with an incorrectly calculated address. In particular, an unset register with a value of 0 is a "bad address". Ensure the address you are trying to access correctly references an item declared in the .data section.'},{type:"heading",text:"Can't Put Data in Text Segment"},{type:"code",text:"Error Message:;Can't put data in text segment on line n of file /*/*.s    .label .type args"},{type:"paragraph",text:"This error message indicates that you are trying to use a directive that belongs in a .data segment in another segment. Most commonly, it is caused by forgetting the .data directive."},{type:"heading",text:"Target of Jump Differs in High-Order 4 Bits from Instruction PC"},{type:"code",text:"Error Message:;Target of jump differs in high-order 4 bits from instruction pc 0x400014"},{type:"paragraph",text:"This error message indicates that you are trying to jump further than a jump instruction will allow. The most common cause is forgetting the .text directive prior to your code (which means the main label will not be within the text segment as expected). This error can also be caused by a jump instruction which accidentally references the label of an item in the .data section."}]}];!function(e){e.MISC="miscellaneous",e.ARITHMETIC="arithmetic",e.BRANCH="branch",e.JUMP="jump",e.MEMORY="memory",e.LOGICAL="logical",e.COMPARISON="comparison",e.SHIFT="shift",e.FLOAT_MOVE_AND_CONVERT="float move and convert",e.FLOAT_ARITHMETIC="float arithmetic",e.FLOAT_CONDITIONAL="float conditional",e.FLOAT_MEMORY="float memory",e.SYSTEM="system"}(i||(i={}));var b=[{id:"move",assemblyName:"move",name:"Move",description:"Move a value from one register to another",category:i.MISC,instructionEncoding:{type:"Pseudo-Instruction",equivalentInstructions:["addiu $t, $s, $0"]},usage:"move $t, $s",result:"t = s",tags:"copy"},{id:"movn",assemblyName:"movn",name:"Move on Not Zero",description:"Move a value if a register is not zero",category:i.MISC,instructionEncoding:{type:"R-Type",opcode:"000000",rs:"sssss",rt:"ttttt",rd:"ddddd",shamt:"-----",funct:"001011"},usage:"movn $d, $s, $t",result:"if (t != 0) d = s;"},{id:"movz",assemblyName:"movz",name:"Move On Zero",description:"Move a value if a register is zero",category:i.MISC,instructionEncoding:{type:"R-Type",opcode:"000000",rs:"sssss",rt:"ttttt",rd:"ddddd",shamt:"-----",funct:"001010"},usage:"movz $d, $s, $t",result:"if (t == 0) d = s;"},{id:"movf",assemblyName:"movf",name:"Move on Floating Point Conditional False",description:"Move a value if a floating point conditional is false",category:i.MISC,instructionEncoding:{type:"RC-Type",opcode:"000000",rs:"sssss",cc:"ccc",cond:"00",rd:"ddddd",shamt:"-----",funct:"000001"},usage:"movf $d, $s, cc",result:"if (!floating point conditional cc) d = s;",notes:"The condition code flag specifies which of the 8 condition codes to check. If it is omitted, 0 is the default."},{id:"movt",assemblyName:"movt",name:"Move on Floating Point Conditional True",description:"Move a value if a floating point conditional is true",category:i.MISC,instructionEncoding:{type:"RC-Type",opcode:"000000",rs:"sssss",cc:"ccc",cond:"01",rd:"ddddd",shamt:"-----",funct:"000001"},usage:"movt $d, $s, cc",result:"if (floating point conditional cc) d = s;",notes:"The condition code flag specifies which of the 8 condition codes to check. If it is omitted, 0 is the default."},{id:"li",assemblyName:"li",name:"Load Immediate",description:"Load an immediate value into a register",category:i.MISC,instructionEncoding:{type:"Pseudo-Instruction",equivalentInstructions:["lui $t, imm[31-16]","ori $t, $t, imm[15-0]"]},usage:"li $t, imm",result:"t = imm",notes:"Since this instruction is commonly used to initialize a register before first use, it is a good idea to leave a comment saying what the register will be used for or the meaning of the constant value.",tags:"initialize constant"},{id:"lui",assemblyName:"lui",name:"Load Upper Immediate",description:"Load an immediate value into the upper 16 bits of a register",category:i.MISC,instructionEncoding:{type:"I-Type",opcode:"001111",rs:"-----",rt:"ttttt",imm:"iiiiiiiiiiiiiiii"},usage:"lui $t, imm",result:"t = imm << 16"},{id:"la",assemblyName:"la",name:"Load Address",description:"Load a label's address into a register",category:i.MISC,instructionEncoding:{type:"Pseudo-Instruction",equivalentInstructions:["lui $t, label[31-16]","ori $t, $t, label[15-0]"]},usage:"la $t, label",result:"t = label"},{id:"syscall",assemblyName:"syscall",name:"Syscall",description:"Request an operation from the system",category:i.MISC,instructionEncoding:{type:"R-Type",opcode:"000000",rs:"-----",rt:"-----",rd:"-----",shamt:"-----",funct:"001100"},usage:"syscall",result:"<depends>",notes:"Syscall can be used for console IO, memory allocation, program termination, and other tasks. See syscall reference for details."},{id:"break",assemblyName:"break",name:"Break",description:"Cause exception with specified code",category:i.MISC,instructionEncoding:{type:"R-Type",opcode:"000000",rs:"-----",rt:"-----",rd:"-----",shamt:"-----",funct:"001101"},usage:"break n",result:"An exception is thrown with code n",notes:"Code 1 is reserved for the debugger."},{id:"nop",assemblyName:"nop",name:"No Operation",description:"Do nothing for a cycle",category:i.MISC,instructionEncoding:{type:"Pseudo-Instruction",equivalentInstructions:["sll $0, $0, $0"]},usage:"nop",result:"<no effect>",notes:"Used to make the processor do nothing for a cycle. For example, a nop may be used after a branch to delay the next instruction until the branch result is computed. The equivalent instruction is a shift of 0 places on an unassignable register (which does nothing), and is easily identified by its binary encoding: 00000000000000000000000000000000."},{id:"add",assemblyName:"add",name:"Add",description:"Add two registers",category:i.ARITHMETIC,instructionEncoding:{type:"R-Type",opcode:"000000",rs:"sssss",rt:"ttttt",rd:"ddddd",shamt:"-----",funct:"100000"},usage:"add $d, $s, $t",result:"d = s + t",tags:"add addition plus"},{id:"addu",assemblyName:"addu",name:"Add Unsigned",description:"Add two registers without overflow",category:i.ARITHMETIC,instructionEncoding:{type:"R-Type",opcode:"000000",rs:"sssss",rt:"ttttt",rd:"ddddd",shamt:"-----",funct:"100001"},usage:"addu $d, $s, $t",result:"d = s + t",tags:"add addition plus"},{id:"addi",assemblyName:"addi",name:"Add Immediate",description:"Add a register and an immediate",category:i.ARITHMETIC,instructionEncoding:{type:"I-Type",opcode:"001000",rs:"sssss",rt:"ttttt",imm:"iiiiiiiiiiiiiiii"},usage:"addi $t, $s, imm",result:"t = s + imm",tags:"add addition plus"},{id:"addiu",assemblyName:"addiu",name:"Add Immediate Unsigned",description:"Add a register and an immediate without overflow",category:i.ARITHMETIC,instructionEncoding:{type:"I-Type",opcode:"001001",rs:"sssss",rt:"ttttt",imm:"iiiiiiiiiiiiiiii"},usage:"addiu $t, $s, imm",result:"t = s + imm",tags:"add addition plus"},{id:"sub",assemblyName:"sub",name:"Subtract",description:"Subtract one register from another register",category:i.ARITHMETIC,instructionEncoding:{type:"R-Type",opcode:"000000",rs:"sssss",rt:"ttttt",rd:"ddddd",shamt:"-----",funct:"100010"},usage:"sub $d, $s, $t",result:"d = s - t",tags:"sub subtraction minus"},{id:"subu",assemblyName:"subu",name:"Subtract Unsigned",description:"Subtract one register from another register without overflow",category:i.ARITHMETIC,instructionEncoding:{type:"R-Type",opcode:"000000",rs:"sssss",rt:"ttttt",rd:"ddddd",shamt:"-----",funct:"100011"},usage:"subu $d, $s, $t",result:"d = s - t",tags:"sub subtraction minus"},{id:"subi",assemblyName:"sub",name:"Subtract Immediate",description:"Subtract an immediate from a register",category:i.ARITHMETIC,instructionEncoding:{type:"Pseudo-Instruction",equivalentInstructions:["addi $t, $s, -imm    # imm > -2^15","","ori $at, $0, imm     # imm == -2^15","sub $t, $s, $at"]},usage:"sub $t, $s, imm",result:"t = s - imm",notes:"MIPS does not provide a subtract immediate instruction because the immediate value can simply be negated by the assembler, and addi used instead. If the value is -2^15 (which cannot be negated in 16 bit 2's complement), two equivalent instructions are needed. This instruction may also be available as subi in environments other than QtSpim.",tags:"sub subtraction minus"},{id:"subiu",assemblyName:"subu",name:"Subtract Immediate Unsigned",description:"Subtract an immediate from a register without overflow",category:i.ARITHMETIC,instructionEncoding:{type:"Pseudo-Instruction",equivalentInstructions:["addiu $t, $s, -imm    # imm > -2^15","","ori $at, $0, imm      # imm == -2^15","subu $t, $s, $at"]},usage:"subu $t, $s, imm",result:"t = s - imm",notes:"MIPS does not provide a subtract immediate unsigned instruction because the immediate value can simply be negated by the assembler, and addiu used instead. If the value is -2^15 (which cannot be negated in 16 bit 2's complement), two equivalent instructions are needed. This instruction may also be available as subiu in environments other than QtSpim.",tags:"sub subtraction minus"},{id:"mult",assemblyName:"mult",name:"Multiply",description:"Multiply two integers",category:i.ARITHMETIC,instructionEncoding:{type:"R-Type",opcode:"000000",rs:"sssss",rt:"ttttt",rd:"-----",shamt:"-----",funct:"011000"},usage:"mult $s, $t",result:"[HI, LO] = s * t",tags:"multiply multiplication times"},{id:"multu",assemblyName:"multu",name:"Multiply Unsigned",description:"Multiply two integers (unsigned)",category:i.ARITHMETIC,instructionEncoding:{type:"R-Type",opcode:"000000",rs:"sssss",rt:"ttttt",rd:"-----",shamt:"-----",funct:"011001"},usage:"multu $s, $t",result:"[HI, LO] = s * t",tags:"multiply multiplication times"},{id:"madd",assemblyName:"madd",name:"Multiply and Add",description:"Multiply two integers and add",category:i.ARITHMETIC,instructionEncoding:{type:"SPECIAL2-Type",opcode:"011100",rs:"sssss",rt:"ttttt",rd:"-----",special:"-----",funct:"000000"},usage:"madd $s, $t",result:"[HI, LO] += s * t",tags:"multiply multiplication times"},{id:"maddu",assemblyName:"maddu",name:"Multiply and Add Unsigned",description:"Multiply two integers and add (unsigned)",category:i.ARITHMETIC,instructionEncoding:{type:"SPECIAL2-Type",opcode:"011100",rs:"sssss",rt:"ttttt",rd:"-----",special:"-----",funct:"000001"},usage:"maddu $s, $t",result:"[HI, LO] += s * t",tags:"multiply multiplication times"},{id:"msub",assemblyName:"msub",name:"Multiply and Subtract",description:"Multiply two integers and subtract",category:i.ARITHMETIC,instructionEncoding:{type:"SPECIAL2-Type",opcode:"011100",rs:"sssss",rt:"ttttt",rd:"-----",special:"-----",funct:"000100"},usage:"msub $s, $t",result:"[HI, LO] -= s * t",tags:"multiply multiplication times"},{id:"msubu",assemblyName:"msubu",name:"Multiply and Subtract Unsigned",description:"Multiply two integers and subtract (unsigned)",category:i.ARITHMETIC,instructionEncoding:{type:"SPECIAL2-Type",opcode:"011100",rs:"sssss",rt:"ttttt",rd:"-----",special:"-----",funct:"000101"},usage:"msubu $s, $t",result:"[HI, LO] -= s * t",tags:"multiply multiplication times"},{id:"mul",assemblyName:"mul",name:"Multiply and Return Lower 32 Bits",description:"Multiply two integers, keeping only the lower 32 bits",category:i.ARITHMETIC,instructionEncoding:{type:"SPECIAL2-Type",opcode:"011100",rs:"sssss",rt:"ttttt",rd:"ddddd",special:"-----",funct:"000010"},usage:"mul $d, $s, $t",result:"d = s * t (lower 32 bits only)",tags:"multiply multiplication times"},{id:"mulo",assemblyName:"mulo",name:"Multiply and Return Lower 32 Bits With Overflow",description:"Multiply two integers, keeping only the lower 32 bits and checking for overflow",category:i.ARITHMETIC,instructionEncoding:{type:"Pseudo-Instruction",equivalentInstructions:["mult $s, $t","mfhi $at","mflo $d","sra $d, $d, 31","beq $at, $d, 8","break","mflo $d"]},usage:"mulo $d, $s, $t",result:"d = s * t (lower 32 bits only)",notes:"Will cause an exception if the result does not fit in 32 bits.",tags:"multiply multiplication times"},{id:"mulou",assemblyName:"mulou",name:"Multiply and Return Lower 32 Bits With Overflow Unsigned",description:"Multiply two integers, keeping only the lower 32 bits and checking for overflow (unsigned)",category:i.ARITHMETIC,instructionEncoding:{type:"Pseudo-Instruction",equivalentInstructions:["multu $s, $t","mfhi $at","beq $at, $0, 8","break","mflo $d"]},usage:"mulou $d, $s, $t",result:"d = s * t (lower 32 bits only)",notes:"Will cause an exception if the result does not fit in 32 bits.",tags:"multiply multiplication times"},{id:"div",assemblyName:"div",name:"Divide",description:"Divide two integers",category:i.ARITHMETIC,instructionEncoding:{type:"R-Type",opcode:"000000",rs:"sssss",rt:"ttttt",rd:"-----",shamt:"-----",funct:"011010"},usage:"div $s, $t",result:"LO = s / t; HI = s % t",tags:"divide division modulo modulus"},{id:"divu",assemblyName:"divu",name:"Divide Unsigned",description:"Divide two integers (unsigned)",category:i.ARITHMETIC,instructionEncoding:{type:"R-Type",opcode:"000000",rs:"sssss",rt:"-----",rd:"-----",shamt:"00000",funct:"011011"},usage:"divu $s, $t",result:"LO = s / t; HI = s % t",tags:"divide division"},{id:"quotient",assemblyName:"div",name:"Divide and return the quotient",description:"Divide two integers, returning only the quotient",category:i.ARITHMETIC,instructionEncoding:{type:"Pseudo-Instruction",equivalentInstructions:["div $s, $t","mflo $d"]},usage:"div $d, $s, $t",result:"d = s / t (whole part only)",tags:"divide division"},{id:"rem",assemblyName:"rem",name:"Divide and return the remainder",description:"Divide two integers, returning only the remainder",category:i.ARITHMETIC,instructionEncoding:{type:"Pseudo-Instruction",equivalentInstructions:["div $s, $t","mfhi $d"]},usage:"rem $d, $s, $t",result:"d = s % t",tags:"divide division modulo modulus"},{id:"mfhi",assemblyName:"mfhi",name:"Move from HI",description:"Move the value in HI to another register",category:i.ARITHMETIC,instructionEncoding:{type:"R-Type",opcode:"000000",rs:"-----",rt:"-----",rd:"ddddd",shamt:"-----",funct:"010000"},usage:"mfhi $d",result:"d = HI"},{id:"mthi",assemblyName:"mthi",name:"Move to HI",description:"Move the value in a register to HI",category:i.ARITHMETIC,instructionEncoding:{type:"R-Type",opcode:"000000",rs:"sssss",rt:"-----",rd:"-----",shamt:"-----",funct:"010001"},usage:"mthi $s",result:"HI = s"},{id:"mflo",assemblyName:"mflo",name:"Move from LO",description:"Move the value in LO to a register",category:i.ARITHMETIC,instructionEncoding:{type:"R-Type",opcode:"000000",rs:"-----",rt:"-----",rd:"ddddd",shamt:"-----",funct:"010010"},usage:"mflo $d",result:"d = LO"},{id:"mtlo",assemblyName:"mtlo",name:"Move to LO",description:"Move the value in a register to LO",category:i.ARITHMETIC,instructionEncoding:{type:"R-Type",opcode:"000000",rs:"sssss",rt:"-----",rd:"-----",shamt:"-----",funct:"010011"},usage:"mtlo $s",result:"LO = s"},{id:"abs",assemblyName:"abs",name:"Absolute Value",description:"Find the absolute value of an integer",category:i.ARITHMETIC,instructionEncoding:{type:"Pseudo-Instruction",equivalentInstructions:["addu $s, $0, $t","bgez $t, 4","sub $s, $0, $t"]},usage:"abs $s, $t",result:"s = |t|"},{id:"neg",assemblyName:"neg",name:"Negate",description:"Find the negation of an integer",category:i.ARITHMETIC,instructionEncoding:{type:"Pseudo-Instruction",equivalentInstructions:["sub $s, $0, $t"]},usage:"neg $s, $t",result:"s = -t"},{id:"b",assemblyName:"b",name:"Branch Unconditionally",description:"Branch with no condition",category:i.BRANCH,instructionEncoding:{type:"Pseudo-Instruction",equivalentInstructions:["beq $0, $0, label"]},usage:"b label",result:"PC = label;"},{id:"bal",assemblyName:"bal",name:"Branch Unconditionally and Link",description:"Branch with no condition and link",category:i.BRANCH,instructionEncoding:{type:"Pseudo-Instruction",equivalentInstructions:["bgezal $0, label"]},usage:"bal label",result:"RA = PC + 4; PC = label;"},{id:"beq",assemblyName:"beq",name:"Branch on Equal",description:"Branch if two registers have the same value",category:i.BRANCH,instructionEncoding:{type:"I-Type",opcode:"000100",rs:"sssss",rt:"ttttt",imm:"iiiiiiiiiiiiiiii"},usage:"beq $s, $t, label",result:"if (s == t) PC = label;"},{id:"beqi",assemblyName:"beq",name:"Branch on Equal to Immediate",description:"Branch if a register is equal to an immediate",category:i.BRANCH,instructionEncoding:{type:"Pseudo-Instruction",equivalentInstructions:["ori $at, $0, imm","beq $t, $at, label"]},usage:"beq $t, imm, label",result:"if (t == imm) PC = label;"},{id:"beqz",assemblyName:"beqz",name:"Branch on Equal to Zero",description:"Branch if a register is equal to zero",category:i.BRANCH,instructionEncoding:{type:"Pseudo-Instruction",equivalentInstructions:["beq $s, $0, C"]},usage:"beqz $s, label",result:"if (s == 0) PC = label;"},{id:"bne",assemblyName:"bne",name:"Branch on not Equal",description:"Branch if two registers do not have the same value",category:i.BRANCH,instructionEncoding:{type:"I-Type",opcode:"000101",rs:"sssss",rt:"ttttt",imm:"iiiiiiiiiiiiiiii"},usage:"bne $s, $t, label",result:"if (s != t) PC = label;"},{id:"bnei",assemblyName:"bne",name:"Branch on not Equal to Immediate",description:"Branch if a register is not equal to an immediate",category:i.BRANCH,instructionEncoding:{type:"Pseudo-Instruction",equivalentInstructions:["ori $at, $0, imm","bne $t, $at, label"]},usage:"bne $t, imm, label",result:"if (t != imm) PC = label;"},{id:"bnez",assemblyName:"bnez",name:"Branch on not equal to Zero",description:"Branch if a register is not equal to zero",category:i.BRANCH,instructionEncoding:{type:"Pseudo-Instruction",equivalentInstructions:["bne $s, $0, C"]},usage:"bnez $s, label",result:"if (s != 0) PC = label;"},{id:"blt",assemblyName:"blt",name:"Branch Less Than",description:"Branch if a register is less than another register",category:i.BRANCH,instructionEncoding:{type:"Pseudo-Instruction",equivalentInstructions:["slt $at, $s, $t","bne $at, $0, label"]},usage:"blt $s, $t, label",result:"if (s < t) PC = label;"},{id:"bltz",assemblyName:"bltz",name:"Branch on Less than Zero",description:"Branch if a register is less than zero",category:i.BRANCH,instructionEncoding:{type:"RI-Type",opcode:"000001",rs:"sssss",regimm:"00000",imm:"iiiiiiiiiiiiiiii"},usage:"bltz $s, label",result:"if (s < 0) PC = label;"},{id:"bltzal",assemblyName:"bltzal",name:"Branch on Less than Zero and Link",description:"Branch if a register is less zero and link",category:i.BRANCH,instructionEncoding:{type:"RI-Type",opcode:"000001",rs:"sssss",regimm:"10000",imm:"iiiiiiiiiiiiiiii"},usage:"bltzal $s, label",result:"if (s < 0) {RA = PC + 4; PC = label;}"},{id:"ble",assemblyName:"ble",name:"Branch Less Than or Equal",description:"Branch if a register is less than or equal to another register",category:i.BRANCH,instructionEncoding:{type:"Pseudo-Instruction",equivalentInstructions:["slt $at, $t, $s","beq $at, $0, label"]},usage:"ble $s, $t, label",result:"if (s <= t) PC = label;"},{id:"blez",assemblyName:"blez",name:"Branch on Less than or Equal to Zero",description:"Branch if a register is less than or equal to zero",category:i.BRANCH,instructionEncoding:{type:"I-Type",opcode:"000110",rs:"sssss",rt:"-----",imm:"iiiiiiiiiiiiiiii"},usage:"blez $s, label",result:"if (s <= 0) PC = label;"},{id:"bgt",assemblyName:"bgt",name:"Branch Greater Than",description:"Branch if a register is greater than another register",category:i.BRANCH,instructionEncoding:{type:"Pseudo-Instruction",equivalentInstructions:["slt $at, $t, $s","bne $at, $0, label"]},usage:"bgt $s, $t, label",result:"if (s > t) PC = label;"},{id:"bgtz",assemblyName:"bgtz",name:"Branch on Greater than Zero",description:"Branch if a register is greater than zero",category:i.BRANCH,instructionEncoding:{type:"I-Type",opcode:"000111",rs:"sssss",rt:"-----",imm:"iiiiiiiiiiiiiiii"},usage:"bgtz $s, label",result:"if (s > 0) PC = label;"},{id:"bgezal",assemblyName:"bgezal",name:"Branch on Greater than or Equal to Zero and Link",description:"Branch if a register is greater than or equal to zero and link",category:i.BRANCH,instructionEncoding:{type:"RI-Type",opcode:"000001",rs:"sssss",regimm:"10001",imm:"iiiiiiiiiiiiiiii"},usage:"bgezal $s, label",result:"if (s >= 0) {RA = PC + 4; PC = label;}"},{id:"bge",assemblyName:"bge",name:"Branch Greater Than or Equal",description:"Branch if a register is greater than or equal to another register",category:i.BRANCH,instructionEncoding:{type:"Pseudo-Instruction",equivalentInstructions:["slt $at, $s, $t","beq $at, $0, label"]},usage:"bge $s, $t, label",result:"if (s >= t) PC = label;"},{id:"bgez",assemblyName:"bgez",name:"Branch on Greater than or Equal to Zero",description:"Branch if a register is  greater than or equal to zero",category:i.BRANCH,instructionEncoding:{type:"RI-Type",opcode:"000001",rs:"sssss",regimm:"00001",imm:"iiiiiiiiiiiiiiii"},usage:"bgez $s, label",result:"if (s >= 0) PC = label;"},{id:"and",assemblyName:"and",name:"Bitwise And",description:"Bitwise and two registers",category:i.LOGICAL,instructionEncoding:{type:"R-Type",opcode:"000000",rs:"sssss",rt:"ttttt",rd:"ddddd",shamt:"00000",funct:"100100"},usage:"and $d, $s, $t",result:"d = s & t"},{id:"andi",assemblyName:"andi",name:"Bitwise And Immediate",description:"Bitwise and a register and an immediate",category:i.LOGICAL,instructionEncoding:{type:"I-Type",opcode:"001100",rs:"sssss",rt:"ttttt",imm:"iiiiiiiiiiiiiiii"},usage:"andi $t, $s, imm",result:"t = s & imm"},{id:"or",assemblyName:"or",name:"Bitwise Or",description:"Bitwise or two registers",category:i.LOGICAL,instructionEncoding:{type:"R-Type",opcode:"000000",rs:"sssss",rt:"ttttt",rd:"ddddd",shamt:"00000",funct:"100101"},usage:"or $d, $s, $t",result:"d = s | t"},{id:"ori",assemblyName:"ori",name:"Bitwise Or Immediate",description:"Bitwise or a register and an immediate",category:i.LOGICAL,instructionEncoding:{type:"I-Type",opcode:"001101",rs:"sssss",rt:"ttttt",imm:"iiiiiiiiiiiiiiii"},usage:"ori $t, $s, imm",result:"t = s | imm"},{id:"xor",assemblyName:"xor",name:"Bitwise Exclusive Or",description:"Bitwise exclusive or two registers",category:i.LOGICAL,instructionEncoding:{type:"R-Type",opcode:"000000",rs:"sssss",rt:"ttttt",rd:"ddddd",shamt:"00000",funct:"100110"},usage:"xor $d, $s, $t",result:"d = s ^ t"},{id:"xori",assemblyName:"xori",name:"Bitwise Exclusive Or Immediate",description:"Bitwise exclusive or a register and an immediate",category:i.LOGICAL,instructionEncoding:{type:"I-Type",opcode:"001110",rs:"sssss",rt:"ttttt",imm:"iiiiiiiiiiiiiiii"},usage:"xori $t, $s, imm",result:"t = s ^ imm"},{id:"nor",assemblyName:"nor",name:"Bitwise Nor",description:"Bitwise nor two registers",category:i.LOGICAL,instructionEncoding:{type:"R-Type",opcode:"000000",rs:"sssss",rt:"ttttt",rd:"ddddd",shamt:"00000",funct:"100111\u202c"},usage:"nor $d, $s, $t",result:"d = ~(s | t)"},{id:"not",assemblyName:"not",name:"Bitwise Not",description:"Bitwise not a register",category:i.LOGICAL,instructionEncoding:{type:"Pseudo-Instruction",equivalentInstructions:["nor $s, $t, $0"]},usage:"not $s, $t",result:"s = ~(t)"},{id:"j",assemblyName:"j",name:"Jump",description:"Jump to a specified label",category:i.JUMP,instructionEncoding:{type:"J-Type",opcode:"000010",addr:"aaaaaaaaaaaaaaaaaaaaaaaaaa"},usage:"j label",result:"PC = label;"},{id:"jal",assemblyName:"jal",name:"Jump and Link",description:"Jump to a specified label and link",category:i.JUMP,instructionEncoding:{type:"J-Type",opcode:"000011",addr:"aaaaaaaaaaaaaaaaaaaaaaaaaa"},usage:"jal label",result:"$ra = PC + 4; PC = label;"},{id:"jr",assemblyName:"jr",name:"Jump Register",description:"Jump to the address in a register",category:i.JUMP,instructionEncoding:{type:"R-Type",opcode:"000000",rs:"sssss",rt:"-----",rd:"-----",shamt:"-----",funct:"001000"},usage:"jr $s",result:"PC = s;"},{id:"jalr",assemblyName:"jalr",name:"Jump Register and Link",description:"Jump to the address in a register and link",category:i.JUMP,instructionEncoding:{type:"R-Type",opcode:"000000",rs:"sssss",rt:"-----",rd:"ddddd",shamt:"-----",funct:"001001"},usage:"jalr $d, $s",result:"d = PC + 4; PC = s;"},{id:"jalr-implied",assemblyName:"jalr",name:"Jump Register and Link (link register implied)",description:"Jump to the address in a register and link (link register implied)",category:i.JUMP,instructionEncoding:{type:"Pseudo-Instruction",equivalentInstructions:["jalr $ra, $s"]},usage:"jalr $s",result:"$ra = PC + 4; PC = s;"},{id:"lb",assemblyName:"lb",name:"Load Byte",description:"Load a (sign-extended) byte from memory to a register",category:i.MEMORY,instructionEncoding:{type:"I-Type",opcode:"100000",rs:"sssss",rt:"ttttt",imm:"iiiiiiiiiiiiiiii"},usage:"lb $t, imm($s)",result:"t = memory[s + imm]"},{id:"lbu",assemblyName:"lbu",name:"Load Byte Unsigned",description:"Load a (zero-padded) byte from memory to a register",category:i.MEMORY,instructionEncoding:{type:"I-Type",opcode:"100100",rs:"sssss",rt:"ttttt",imm:"iiiiiiiiiiiiiiii"},usage:"lbu $t, imm($s)",result:"t = memory[s + imm]"},{id:"lh",assemblyName:"lh",name:"Load Half Word",description:"Load a (sign-extended) half word from memory to a register",category:i.MEMORY,instructionEncoding:{type:"I-Type",opcode:"100001",rs:"sssss",rt:"ttttt",imm:"iiiiiiiiiiiiiiii"},usage:"lh $t, imm($s)",result:"t = memory[s + imm]"},{id:"lhu",assemblyName:"lhu",name:"Load Half Word Unsigned",description:"Load a (zero-padded) half word from memory to a register",category:i.MEMORY,instructionEncoding:{type:"I-Type",opcode:"100101",rs:"sssss",rt:"ttttt",imm:"iiiiiiiiiiiiiiii"},usage:"lhu $t, imm($s)",result:"t = memory[s + imm]"},{id:"lw",assemblyName:"lw",name:"Load Word",description:"Load a word from memory to a register",category:i.MEMORY,instructionEncoding:{type:"I-Type",opcode:"100011",rs:"sssss",rt:"ttttt",imm:"iiiiiiiiiiiiiiii"},usage:"lw $t, imm($s)",result:"t = memory[s + imm]",notes:"Getting an unaligned address error with load word? The address must be aligned with a word boundary (i.e. it must be a multiple of 4). Double check the math you used to calculate the address, and check if you need to add a .align directive in your .data section."},{id:"lw-label",assemblyName:"lw",name:"Load Word Label",description:"Load a word from memory to a register by label",category:i.MEMORY,instructionEncoding:{type:"Pseudo-Instruction",equivalentInstructions:["lui $at, label[31-16]","ori $at, $at, label[15-0]","lw $t, 0($at)"]},usage:"lw $t, label",result:"t = memory[label]",notes:"Getting an unaligned address error with load word? The address must be aligned with a word boundary (i.e. it must be a multiple of 4). Check if you need to add a .align directive in your .data section."},{id:"sb",assemblyName:"sb",name:"Store Byte",description:"Store a byte from a register to memory",category:i.MEMORY,instructionEncoding:{type:"I-Type",opcode:"101000",rs:"sssss",rt:"ttttt",imm:"iiiiiiiiiiiiiiii"},usage:"sb $t, imm($s)",result:"memory[s + imm] = t"},{id:"sh",assemblyName:"sh",name:"Store Half Word",description:"Store a half word from a register to memory",category:i.MEMORY,instructionEncoding:{type:"I-Type",opcode:"101000",rs:"sssss",rt:"ttttt",imm:"iiiiiiiiiiiiiiii"},usage:"sh $t, imm($s)",result:"memory[s + imm] = t"},{id:"sw",assemblyName:"sw",name:"Store Word",description:"Store a word from a register to memory",category:i.MEMORY,instructionEncoding:{type:"I-Type",opcode:"101011",rs:"sssss",rt:"ttttt",imm:"iiiiiiiiiiiiiiii"},usage:"sw $t, imm($s)",result:"memory[s + imm] = t",notes:"Getting an unaligned address error with store word? The address must be aligned with a word boundary (i.e. it must be a multiple of 4). Double check the math you used to calculate the address, and check if you need to add a .align directive in your .data section."},{id:"sw-label",assemblyName:"sw",name:"Store Word Label",description:"Store a word from a register to memory by label",category:i.MEMORY,instructionEncoding:{type:"Pseudo-Instruction",equivalentInstructions:["lui $at, label[31-16]","ori $at, $at, label[15-0]","sw $t, 0($at)"]},usage:"sw $t, label",result:"memory[label] = t",notes:"Getting an unaligned address error with store word? The address must be aligned with a word boundary (i.e. it must be a multiple of 4). Check if you need to add a .align directive in your .data section."},{id:"seq",assemblyName:"seq",name:"Set on Equal",description:"Check is a register is equal to than another register",category:i.COMPARISON,instructionEncoding:{type:"Pseudo-Instruction",equivalentInstructions:["beq $s, $t, 8","ori $d, $0, 0","beq $0, $0, 4","ori $d, $0, 1"]},usage:"seq $d, $s, $t",result:"d = s == t"},{id:"sne",assemblyName:"sne",name:"Set on Not Equal",description:"Check is a register is not equal to than another register",category:i.COMPARISON,instructionEncoding:{type:"Pseudo-Instruction",equivalentInstructions:["beq $s, $t, 8","ori $d, $0, 1","beq $0, $0, 4","ori $d, $0, 0"]},usage:"sne $d, $s, $t",result:"d = s != t"},{id:"slt",assemblyName:"slt",name:"Set on Less Than",description:"Check is a register is less than another register",category:i.COMPARISON,instructionEncoding:{type:"R-Type",opcode:"000000",rs:"sssss",rt:"ttttt",rd:"ddddd",shamt:"-----",funct:"101010"},usage:"slt $d, $s, $t",result:"d = s < t"},{id:"sltu",assemblyName:"sltu",name:"Set on Less Than Unsigned",description:"Check is a register is less than another register (unsigned)",category:i.COMPARISON,instructionEncoding:{type:"R-Type",opcode:"000000",rs:"sssss",rt:"ttttt",rd:"ddddd",shamt:"-----",funct:"101011"},usage:"sltu $d, $s, $t",result:"d = s < t"},{id:"slti",assemblyName:"slti",name:"Set on Less Than Immediate",description:"Check is a register is less than an immediate",category:i.COMPARISON,instructionEncoding:{type:"I-Type",opcode:"001010",rs:"sssss",rt:"ttttt",imm:"iiiiiiiiiiiiiiii"},usage:"slti $s, $t, imm",result:"s = t < imm"},{id:"sltiu",assemblyName:"sltiu",name:"Set on Less Than Immediate Unsigned",description:"Check is a register is less than an immediate (unsigned)",category:i.COMPARISON,instructionEncoding:{type:"I-Type",opcode:"001011",rs:"sssss",rt:"ttttt",imm:"iiiiiiiiiiiiiiii"},usage:"sltiu $s, $t, imm",result:"s = t < imm"},{id:"sle",assemblyName:"sle",name:"Set on Less Than or Equal",description:"Check is a register is less than or equal to than another register",category:i.COMPARISON,instructionEncoding:{type:"Pseudo-Instruction",equivalentInstructions:["bne $s, $t, 8","ori $d, $0, 1","beq $0, $0, 4","slt $d, $s, $t"]},usage:"sle $d, $s, $t",result:"d = s <= t"},{id:"sleu",assemblyName:"sleu",name:"Set on Less Than or Equal Unsigned",description:"Check is a register is less than or equal to than another register (unsigned)",category:i.COMPARISON,instructionEncoding:{type:"Pseudo-Instruction",equivalentInstructions:["bne $s, $t, 8","ori $d, $0, 1","beq $0, $0, 4","sltu $d, $s, $t"]},usage:"sleu $d, $s, $t",result:"d = s <= t"},{id:"sgt",assemblyName:"sgt",name:"Set on Greater Than",description:"Check is a register is greater than another register",category:i.COMPARISON,instructionEncoding:{type:"Pseudo-Instruction",equivalentInstructions:["slt $d, $t, $s"]},usage:"sgt $d, $s, $t",result:"d = s > t"},{id:"sgtu",assemblyName:"sgtu",name:"Set on Greater Than Unsigned",description:"Check is a register is greater than another register (unsigned)",category:i.COMPARISON,instructionEncoding:{type:"Pseudo-Instruction",equivalentInstructions:["sltu $d, $t, $s"]},usage:"sgtu $d, $s, $t",result:"d = s > t"},{id:"sge",assemblyName:"sge",name:"Set on Greater Than or Equal",description:"Check is a register is greater than or equal to than another register",category:i.COMPARISON,instructionEncoding:{type:"Pseudo-Instruction",equivalentInstructions:["bne $s, $t, 8","ori $d, $0, 1","beq $0, $0, 4","slt $d, $t, $s"]},usage:"sge $d, $s, $t",result:"d = s >= t"},{id:"sgeu",assemblyName:"sgeu",name:"Set on Greater Than or Equal Unsigned",description:"Check is a register is greater than or equal to than another register (unsigned)",category:i.COMPARISON,instructionEncoding:{type:"Pseudo-Instruction",equivalentInstructions:["bne $s, $t, 8","ori $d, $0, 1","beq $0, $0, 4","sltu $d, $t, $s"]},usage:"sgeu $d, $s, $t",result:"d = s >= t"},{id:"sllv",assemblyName:"sllv",name:"Shift Left Logical",description:"Shift the contents of a register left by an amount from a register",category:i.SHIFT,instructionEncoding:{type:"R-Type",opcode:"000000",rs:"sssss",rt:"ttttt",rd:"ddddd",shamt:"-----",funct:"000100"},usage:"sllv $d, $t, $s",result:"d = t << s",notes:"Only the least significant 5 bits of $s are used."},{id:"sll",assemblyName:"sll",name:"Shift Left Logical Immediate",description:"Shift the contents of a register left by an immediate amount",category:i.SHIFT,instructionEncoding:{type:"R-Type",opcode:"000000",rs:"-----",rt:"ttttt",rd:"ddddd",shamt:"iiiii",funct:"000000"},usage:"sll $d, $t, imm",result:"d = t << imm"},{id:"srlv",assemblyName:"srlv",name:"Shift Right Logical",description:"Shift the contents of a register right by an amount from a register (zero-padded)",category:i.SHIFT,instructionEncoding:{type:"R-Type",opcode:"000000",rs:"sssss",rt:"ttttt",rd:"ddddd",shamt:"-----",funct:"000110"},usage:"srlv $d, $t, $s",result:"d = t >> s",notes:"Only the least significant 5 bits of $s are used."},{id:"srl",assemblyName:"srl",name:"Shift Right Logical Immediate",description:"Shift the contents of a register right by an immediate amount (zero-padded)",category:i.SHIFT,instructionEncoding:{type:"R-Type",opcode:"000000",rs:"-----",rt:"ttttt",rd:"ddddd",shamt:"iiiii",funct:"000010"},usage:"srl $d, $t, imm",result:"d = t >> imm"},{id:"srav",assemblyName:"srav",name:"Shift Right Arithmetic",description:"Shift the contents of a register right by an amount from a register (sign-extended)",category:i.SHIFT,instructionEncoding:{type:"R-Type",opcode:"000000",rs:"sssss",rt:"ttttt",rd:"ddddd",shamt:"-----",funct:"000111"},usage:"srav $d, $t, $s",result:"d = t >> s",notes:"Only the least significant 5 bits of $s are used."},{id:"sra",assemblyName:"sra",name:"Shift Right Arithmetic Immediate",description:"Shift the contents of a register right by the specified number of places (sign-extended)",category:i.SHIFT,instructionEncoding:{type:"R-Type",opcode:"000000",rs:"-----",rt:"ttttt",rd:"ddddd",shamt:"iiiii",funct:"000011"},usage:"sra $d, $t, imm",result:"d = t >> imm"},{id:"rol",assemblyName:"rol",name:"Rotate Left",description:"Rotate the contents of a register left by an amount from a register",category:i.SHIFT,instructionEncoding:{type:"Pseudo-Instruction",equivalentInstructions:["subu $at, $0, $s","srlv $at, $t, $at","sllv $d, $s, $t","or $d, $d, $at"]},usage:"rol $d, $t, $s",result:"d = rotateLeft(t, s)",notes:"Only the least significant 5 bits of $s are used.",tags:"circular shift"},{id:"ror",assemblyName:"ror",name:"Rotate Right",description:"Rotate the contents of a register right by an amount from a register",category:i.SHIFT,instructionEncoding:{type:"Pseudo-Instruction",equivalentInstructions:["subu $at, $0, $s","sllv $at, $t, $at","srlv $d, $s, $t","or $d, $d, $at"]},usage:"rol $d, $t, $s",result:"d = rotateRight(t, s)",notes:"Only the least significant 5 bits of $s are used.",tags:"circular shift"},{id:"roli",assemblyName:"rol",name:"Rotate Left Immediate",description:"Rotate the contents of a register left by the specified number of places",category:i.SHIFT,instructionEncoding:{type:"Pseudo-Instruction",equivalentInstructions:["srl $at, $t, (32 - imm)","sll $d, $t, imm","or $d, $d, $at"]},usage:"rol $d, $t, imm",result:"d = rotateLeft(t, imm)",tags:"circular shift"},{id:"rori",assemblyName:"ror",name:"Rotate Right Immediate",description:"Rotate the contents of a register right by the specified number of places",category:i.SHIFT,instructionEncoding:{type:"Pseudo-Instruction",equivalentInstructions:["sll $at, $t, (32 - imm)","srl $d, $t, imm","or $d, $d, $at"]},usage:"rol $d, $t, imm",result:"d = rotateRight(t, imm)",tags:"circular shift"},{id:"mtc1",assemblyName:"mtc1",name:"Move to Coprocessor 1",description:"Move a value from a general-purpose register to a floating point register",category:i.FLOAT_MOVE_AND_CONVERT,instructionEncoding:{type:"COP-Type",opcode:"\u202d010001",funct:"00100",rt:"ttttt",rd:"ddddd",addr:"-----------"},usage:"mtc1 $t, $d",result:"d = t",notes:"The first argument is the register from the main processor, the second is the register from the coprocessor. Unlike most MIPS instructions, the destination of the operation is not listed first."},{id:"mfc1",assemblyName:"mfc1",name:"Move from Coprocessor 1",description:"Move a value from a floating point register to a general-purpose register",category:i.FLOAT_MOVE_AND_CONVERT,instructionEncoding:{type:"COP-Type",opcode:"\u202d010001",funct:"00000",rt:"ttttt",rd:"ddddd",addr:"-----------"},usage:"mtc1 $t, $d",result:"t = d",notes:"The first argument is the register from the main processor, the second is the register from the coprocessor."},{id:"mov-s",assemblyName:"mov.s",name:"Floating Point Move Single",description:"Move a single-precision float to another register",category:i.FLOAT_MOVE_AND_CONVERT,instructionEncoding:{type:"F-Type",opcode:"\u202d010001",format:"00000",ft:"-----",fs:"sssss",fd:"ddddd",funct:"000110"},usage:"mov.s $d, $s",result:"d = s",tags:"copy"},{id:"mov-d",assemblyName:"mov.d",name:"Floating Point Move Double",description:"Move a double-precision float to another register",category:i.FLOAT_MOVE_AND_CONVERT,instructionEncoding:{type:"F-Type",opcode:"\u202d010001",format:"00001",ft:"-----",fs:"sssss",fd:"ddddd",funct:"000110"},usage:"mov.d $d, $s",result:"d = s",tags:"copy"},{id:"movz-s",assemblyName:"movz.s",name:"Floating Point Move on Zero Single",description:"Move a single-precision float if another register is zero",category:i.FLOAT_MOVE_AND_CONVERT,instructionEncoding:{type:"F-Type",opcode:"\u202d010001",format:"\u202d010000",ft:"ttttt",fs:"sssss",fd:"ddddd",funct:"\u202d010010"},usage:"movz.s $d, $s, $t",result:"if (t == 0) d = s;",tags:"copy"},{id:"movz-d",assemblyName:"movz.d",name:"Floating Point Move on Zero Double",description:"Move a double-precision float if another register is zero",category:i.FLOAT_MOVE_AND_CONVERT,instructionEncoding:{type:"F-Type",opcode:"\u202d010001",format:"\u202d010001",ft:"ttttt",fs:"sssss",fd:"ddddd",funct:"\u202d010010\u202c"},usage:"movz.d $d, $s, $t",result:"if (t == 0) d = s;",tags:"copy"},{id:"movn-s",assemblyName:"movn.s",name:"Floating Point Move on Not Zero Single",description:"Move a single-precision float if another register is not zero",category:i.FLOAT_MOVE_AND_CONVERT,instructionEncoding:{type:"F-Type",opcode:"\u202d010001",format:"\u202d010000",ft:"ttttt",fs:"sssss",fd:"ddddd",funct:"\u202d010011\u202c"},usage:"movn.s $d, $s, $t",result:"if (t != 0) d = s;",tags:"copy"},{id:"movn-d",assemblyName:"movn.d",name:"Floating Point Move on Not Zero Double",description:"Move a double-precision float if another register is not zero",category:i.FLOAT_MOVE_AND_CONVERT,instructionEncoding:{type:"F-Type",opcode:"\u202d010001",format:"\u202d010001",ft:"ttttt",fs:"sssss",fd:"ddddd",funct:"\u202d010011\u202c"},usage:"movn.d $d, $s, $t",result:"if (t != 0) d = s;",tags:"copy"},{id:"cvt-s-w",assemblyName:"cvt.s.w",name:"Convert Word to Single",description:"Convert an integer to a single-precision float",category:i.FLOAT_MOVE_AND_CONVERT,instructionEncoding:{type:"F-Type",opcode:"\u202d010001",format:"10100",ft:"-----",fs:"sssss",fd:"ddddd",funct:"100000\u202c"},usage:"cvt.s.w $d, $s",result:"d = (float) s"},{id:"cvt-d-w",assemblyName:"cvt.d.w",name:"Convert Word to Double",description:"Convert an integer to a double-precision float",category:i.FLOAT_MOVE_AND_CONVERT,instructionEncoding:{type:"F-Type",opcode:"\u202d010001",format:"10001",ft:"-----",fs:"sssss",fd:"ddddd",funct:"100001\u202c"},usage:"cvt.d.w $d, $s",result:"d = (double) s"},{id:"cvt-w-s",assemblyName:"cvt.w.s",name:"Convert Single to Word",description:"Convert a single-precision float to an integer",category:i.FLOAT_MOVE_AND_CONVERT,instructionEncoding:{type:"F-Type",opcode:"\u202d010001",format:"10000",ft:"-----",fs:"sssss",fd:"ddddd",funct:"100100\u202c"},usage:"cvt.w.s $d, $s",result:"d = (int) s"},{id:"cvt-d-s",assemblyName:"cvt.d.s",name:"Convert Single to Double",description:"Convert a single-precision float to a double-precision float",category:i.FLOAT_MOVE_AND_CONVERT,instructionEncoding:{type:"F-Type",opcode:"\u202d010001",format:"10000",ft:"-----",fs:"sssss",fd:"ddddd",funct:"100001\u202c"},usage:"cvt.d.s $d, $s",result:"d = (double) s"},{id:"cvt-w-d",assemblyName:"cvt.w.d",name:"Convert Double to Word",description:"Convert a double-precision float to an integer",category:i.FLOAT_MOVE_AND_CONVERT,instructionEncoding:{type:"F-Type",opcode:"\u202d010001",format:"10001",ft:"-----",fs:"sssss",fd:"ddddd",funct:"100100\u202c"},usage:"cvt.w.d $d, $s",result:"d = (int) s"},{id:"cvt-s-d",assemblyName:"cvt.s.d",name:"Convert Double to Single",description:"Convert a double-precision float to a single-precision float",category:i.FLOAT_MOVE_AND_CONVERT,instructionEncoding:{type:"F-Type",opcode:"\u202d010001",format:"10001",ft:"-----",fs:"sssss",fd:"ddddd",funct:"100000\u202c"},usage:"cvt.s.d $d, $s",result:"d = (float) s"},{id:"round-w-s",assemblyName:"round.w.s",name:"Floating Point Round to Word Single",description:"Round a single-precision float to an integer",category:i.FLOAT_MOVE_AND_CONVERT,instructionEncoding:{type:"F-Type",opcode:"\u202d010001",format:"00000",ft:"-----",fs:"sssss",fd:"ddddd",funct:"\u202d001100\u202c"},usage:"round.w.s $d, $s",result:"d = round(s)"},{id:"round-w-d",assemblyName:"round.w.d",name:"Floating Point Round to Word Double",description:"Round a double-precision float to an integer",category:i.FLOAT_MOVE_AND_CONVERT,instructionEncoding:{type:"F-Type",opcode:"\u202d010001",format:"00001",ft:"-----",fs:"sssss",fd:"ddddd",funct:"\u202d001100\u202c"},usage:"round.w.d $d, $s",result:"d = round(s)"},{id:"trunc-w-s",assemblyName:"trunc.w.s",name:"Floating Point Truncate to Word Single",description:"Truncate a single-precision float to an integer",category:i.FLOAT_MOVE_AND_CONVERT,instructionEncoding:{type:"F-Type",opcode:"\u202d010001",format:"00000",ft:"-----",fs:"sssss",fd:"ddddd",funct:"\u202d001101\u202c"},usage:"trunc.w.s $d, $s",result:"d = trunc(s)"},{id:"trunc-w-d",assemblyName:"trunc.w.d",name:"Floating Point Truncate to Word Double",description:"Truncate a double-precision float to an integer",category:i.FLOAT_MOVE_AND_CONVERT,instructionEncoding:{type:"F-Type",opcode:"\u202d010001",format:"00001",ft:"-----",fs:"sssss",fd:"ddddd",funct:"\u202d001101\u202c"},usage:"trunc.w.d $d, $s",result:"d = trunc(s)"},{id:"ceil-w-s",assemblyName:"ceil.w.s",name:"Floating Point Ceiling to Word Single",description:"Calculate the ceiling of a single-precision float as an integer",category:i.FLOAT_MOVE_AND_CONVERT,instructionEncoding:{type:"F-Type",opcode:"\u202d010001",format:"00000",ft:"-----",fs:"sssss",fd:"ddddd",funct:"00\u202d1110\u202c"},usage:"ceil.w.s $d, $s",result:"d = \u2308s\u2309"},{id:"ceil-w-d",assemblyName:"ceil.w.d",name:"Floating Point Ceiling to Word Double",description:"Calculate the ceiling of a double-precision float as an integer",category:i.FLOAT_MOVE_AND_CONVERT,instructionEncoding:{type:"F-Type",opcode:"\u202d010001",format:"00001",ft:"-----",fs:"sssss",fd:"ddddd",funct:"00\u202d1110\u202c"},usage:"ceil.w.d $d, $s",result:"d = \u2308s\u2309"},{id:"floor-w-s",assemblyName:"floor.w.s",name:"Floating Point Floor to Word Single",description:"Calculate the floor of a single-precision float as an integer",category:i.FLOAT_MOVE_AND_CONVERT,instructionEncoding:{type:"F-Type",opcode:"\u202d010001",format:"00000",ft:"-----",fs:"sssss",fd:"ddddd",funct:"00\u202d1111"},usage:"floor.w.s $d, $s",result:"d = \u230as\u230b"},{id:"floor-w-d",assemblyName:"floor.w.d",name:"Floating Point Floor to Word Double",description:"Calculate the floor of a double-precision float as an integer",category:i.FLOAT_MOVE_AND_CONVERT,instructionEncoding:{type:"F-Type",opcode:"\u202d010001",format:"00001",ft:"-----",fs:"sssss",fd:"ddddd",funct:"00\u202d1111\u202c"},usage:"floor.w.d $d, $s",result:"d = \u230as\u230b"},{id:"add-s",assemblyName:"add.s",name:"Floating Point Addition Single",description:"Calculate the sum of two single-precision floats",category:i.FLOAT_ARITHMETIC,instructionEncoding:{type:"F-Type",opcode:"\u202d010001",format:"10000",ft:"sssss",fs:"sssss",fd:"ddddd",funct:"000000"},usage:"add.s $d, $s, $t",result:"d = s + t",tags:"add addition plus"},{id:"add-d",assemblyName:"add.d",name:"Floating Point Addition Double",description:"Calculate the sum of two double-precision floats",category:i.FLOAT_ARITHMETIC,instructionEncoding:{type:"F-Type",opcode:"\u202d010001",format:"10001",ft:"sssss",fs:"sssss",fd:"ddddd",funct:"000000"},usage:"add.d $d, $s, $t",result:"d = s + t",tags:"addition plus"},{id:"sub-s",assemblyName:"sub.s",name:"Floating Point Subtraction Single",description:"Calculate the difference of two single-precision floats",category:i.FLOAT_ARITHMETIC,instructionEncoding:{type:"F-Type",opcode:"\u202d010001",format:"10000",ft:"sssss",fs:"sssss",fd:"ddddd",funct:"000001"},usage:"sub.s $d, $s, $t",result:"d = s - t",tags:"subtraction minus"},{id:"sub-d",assemblyName:"sub.d",name:"Floating Point Subtraction Double",description:"Calculate the difference of two double-precision floats",category:i.FLOAT_ARITHMETIC,instructionEncoding:{type:"F-Type",opcode:"\u202d010001",format:"10001",ft:"sssss",fs:"sssss",fd:"ddddd",funct:"000001"},usage:"sub.d $d, $s, $t",result:"d = s - t",tags:"subtraction minus"},{id:"mul-s",assemblyName:"mul.s",name:"Floating Point Multiplication Single",description:"Calculate the product of two single-precision floats",category:i.FLOAT_ARITHMETIC,instructionEncoding:{type:"F-Type",opcode:"\u202d010001",format:"\u202d10000",ft:"sssss",fs:"sssss",fd:"ddddd",funct:"000010"},usage:"mul.s $d, $s, $t",result:"d = s * t",tags:"multiply multiplication times"},{id:"mul-d",assemblyName:"mul.d",name:"Floating Point Multiplication Double",description:"Calculate the product of two double-precision floats",category:i.FLOAT_ARITHMETIC,instructionEncoding:{type:"F-Type",opcode:"\u202d010001",format:"\u202d10001",ft:"sssss",fs:"sssss",fd:"ddddd",funct:"000010"},usage:"mul.d $d, $s, $t",result:"d = s * t",tags:"multiply multiplication times"},{id:"div-s",assemblyName:"div.s",name:"Floating Point Division Single",description:"Calculate the quotient of two single-precision floats",category:i.FLOAT_ARITHMETIC,instructionEncoding:{type:"F-Type",opcode:"\u202d010001",format:"\u202d10000",ft:"sssss",fs:"sssss",fd:"ddddd",funct:"000011"},usage:"div.s $d, $s, $t",result:"d = s / t",tags:"divide division"},{id:"div-d",assemblyName:"div.d",name:"Floating Point Division Double",description:"Calculate the quotient of two double-precision floats",category:i.FLOAT_ARITHMETIC,instructionEncoding:{type:"F-Type",opcode:"\u202d010001",format:"10001",ft:"sssss",fs:"sssss",fd:"ddddd",funct:"000011"},usage:"div.d $d, $s, $t",result:"d = s / t",tags:"divide division"},{id:"sqrt-s",assemblyName:"sqrt.s",name:"Floating Point Square Root Single",description:"Calculate the square root of a single-precision float",category:i.FLOAT_ARITHMETIC,instructionEncoding:{type:"F-Type",opcode:"\u202d010001",format:"\u202d10000",ft:"sssss",fs:"sssss",fd:"ddddd",funct:"000100"},usage:"sqrt.s $d, $s",result:"d = sqrt(s)"},{id:"sqrt-d",assemblyName:"sqrt.d",name:"Floating Point Square Root Double",description:"Calculate the square root of a double-precision float",category:i.FLOAT_ARITHMETIC,instructionEncoding:{type:"F-Type",opcode:"\u202d010001",format:"\u202d10001",ft:"sssss",fs:"sssss",fd:"ddddd",funct:"000100"},usage:"sqrt.d $d, $s",result:"d = sqrt(s)"},{id:"abs-s",assemblyName:"abs.s",name:"Floating Point Absolute Value Single",description:"Calculate the absolute value of a single-precision float",category:i.FLOAT_ARITHMETIC,instructionEncoding:{type:"F-Type",opcode:"\u202d010001",format:"00000",ft:"-----",fs:"sssss",fd:"ddddd",funct:"000101"},usage:"abs.s $d, $s",result:"d = |s|"},{id:"abs-d",assemblyName:"abs.d",name:"Floating Point Absolute Value Double",description:"Calculate the absolute value of a double-precision float",category:i.FLOAT_ARITHMETIC,instructionEncoding:{type:"F-Type",opcode:"\u202d010001",format:"00001",ft:"-----",fs:"sssss",fd:"ddddd",funct:"000101"},usage:"abs.d $d, $s",result:"d = |s|"},{id:"neg-s",assemblyName:"neg.s",name:"Floating Point Negation Single",description:"Calculate the negation of a single-precision float",category:i.FLOAT_ARITHMETIC,instructionEncoding:{type:"F-Type",opcode:"\u202d010001",format:"00000",ft:"-----",fs:"sssss",fd:"ddddd",funct:"000111"},usage:"neg.s $d, $s",result:"d = -s"},{id:"neg-d",assemblyName:"neg.d",name:"Floating Point Negation Double",description:"Calculate the negation of a double-precision float",category:i.FLOAT_ARITHMETIC,instructionEncoding:{type:"F-Type",opcode:"\u202d010001",format:"00001",ft:"-----",fs:"sssss",fd:"ddddd",funct:"000111"},usage:"neg.d $d, $s",result:"d = -s"},{id:"c-eq-s",assemblyName:"c.eq.s",name:"Floating Point Compare Equal Single",description:"Check if two single-precision floats are equal",category:i.FLOAT_CONDITIONAL,instructionEncoding:{type:"FCT-Type",opcode:"\u202d010001",format:"10000",ft:"ttttt",fs:"sssss",cc:"ccc",cond:"--",fc:"11",funct:"0010"},usage:"c.eq.s cc, $s, $t",result:"conditional cc = s == t",notes:"The condition code flag specifies which of the 8 condition codes to store the result in. If it is omitted, 0 is the default."},{id:"c-eq-d",assemblyName:"c.eq.d",name:"Floating Point Compare Equal Double",description:"Check if two double-precision floats are equal",category:i.FLOAT_CONDITIONAL,instructionEncoding:{type:"FCT-Type",opcode:"\u202d010001",format:"10001",ft:"ttttt",fs:"sssss",cc:"ccc",cond:"--",fc:"11",funct:"0010"},usage:"c.eq.d cc, $s, $t",result:"conditional cc = s == t",notes:"The condition code flag specifies which of the 8 condition codes to store the result in. If it is omitted, 0 is the default."},{id:"c-le-s",assemblyName:"c.le.s",name:"Floating Point Compare Less Than or Equal Single",description:"Check if a single-precision float is less than or equal to another single",category:i.FLOAT_CONDITIONAL,instructionEncoding:{type:"FCT-Type",opcode:"\u202d010001",format:"10000",ft:"ttttt",fs:"sssss",cc:"ccc",cond:"--",fc:"11",funct:"1110\u202c"},usage:"c.le.s cc, $s, $t",result:"conditional cc = s <= t",notes:"The condition code flag specifies which of the 8 condition codes to store the result in. If it is omitted, 0 is the default."},{id:"c-le-d",assemblyName:"c.le.d",name:"Floating Point Compare Less Than or Equal Double",description:"Check if a double-precision float is less than or equal to another double",category:i.FLOAT_CONDITIONAL,instructionEncoding:{type:"FCT-Type",opcode:"\u202d010001",format:"10001",ft:"ttttt",fs:"sssss",cc:"ccc",cond:"--",fc:"11",funct:"1110\u202c"},usage:"c.le.d cc, $s, $t",result:"conditional cc = s <= t",notes:"The condition code flag specifies which of the 8 condition codes to store the result in. If it is omitted, 0 is the default."},{id:"c-lt-s",assemblyName:"c.lt.s",name:"Floating Point Compare Less Than Single",description:"Check if a single-precision float is less than another single",category:i.FLOAT_CONDITIONAL,instructionEncoding:{type:"FCT-Type",opcode:"\u202d010001",format:"10000",ft:"ttttt",fs:"sssss",cc:"ccc",cond:"--",fc:"11",funct:"1100\u202c"},usage:"c.lt.s cc, $s, $t",result:"conditional cc = s < t",notes:"The condition code flag specifies which of the 8 condition codes to store the result in. If it is omitted, 0 is the default."},{id:"c-lt-d",assemblyName:"c.lt.d",name:"Floating Point Compare Less Than Double",description:"Check if a double-precision float is less than another double",category:i.FLOAT_CONDITIONAL,instructionEncoding:{type:"FCT-Type",opcode:"\u202d010001",format:"10001",ft:"ttttt",fs:"sssss",cc:"ccc",cond:"--",fc:"11",funct:"1100\u202c"},usage:"c.lt.d cc, $s, $t",result:"conditional cc = s < t",notes:"The condition code flag specifies which of the 8 condition codes to store the result in. If it is omitted, 0 is the default."},{id:"bc1f",assemblyName:"bc1f",name:"Branch on Conditional False",description:"Branch if a floating point conditional is false",category:i.FLOAT_CONDITIONAL,instructionEncoding:{type:"IC-Type",opcode:"\u202d010001",format:"\u202d01000",cc:"ccc",cond:"00",imm:"iiiiiiiiiiiiiiii"},usage:"bc1f cc label",result:"if (!conditional cc) PC = label;",notes:"The condition code flag specifies which of the 8 condition codes to check. If it is omitted, 0 is the default."},{id:"bc1t",assemblyName:"bc1t",name:"Branch on Conditional True",description:"Branch if a floating point conditional is true",category:i.FLOAT_CONDITIONAL,instructionEncoding:{type:"IC-Type",opcode:"\u202d010001",format:"\u202d01000",cc:"ccc",cond:"01",imm:"iiiiiiiiiiiiiiii"},usage:"bc1t cc label",result:"if (conditional cc) PC = label;",notes:"The condition code flag specifies which of the 8 condition codes to check. If it is omitted, 0 is the default."},{id:"movf-s",assemblyName:"movf.s",name:"Floating Point Move on Conditional False Single",description:"Move a single-precision float to another register if a conditional is false",category:i.FLOAT_CONDITIONAL,instructionEncoding:{type:"FCO-Type",opcode:"\u202d010001",format:"10000",cc:"ccc",cond:"00",fs:"sssss",fd:"ddddd",funct:"010001"},usage:"movf.s $fd, $fs, cc",result:"if (!conditional cc) d = s;",notes:"The condition code flag specifies which of the 8 condition codes to check. If it is omitted, 0 is the default."},{id:"movf-d",assemblyName:"movf.d",name:"Floating Point Move on Conditional False Double",description:"Move a double-precision float to another register if a conditional is false",category:i.FLOAT_CONDITIONAL,instructionEncoding:{type:"FCO-Type",opcode:"\u202d010001",format:"\u202d10001",cc:"ccc",cond:"00",fs:"sssss",fd:"ddddd",funct:"010001"},usage:"movf.s $fd, $fs, cc",result:"if (!conditional cc) d = s;",notes:"The condition code flag specifies which of the 8 condition codes to check. If it is omitted, 0 is the default."},{id:"movt-s",assemblyName:"movt.s",name:"Floating Point Move on Conditional True Single",description:"Move a single-precision float to another register if a conditional is true",category:i.FLOAT_CONDITIONAL,instructionEncoding:{type:"FCO-Type",opcode:"\u202d010001",format:"10000",cc:"ccc",cond:"01",fs:"sssss",fd:"ddddd",funct:"010001"},usage:"movt.s $fd, $fs, cc",result:"if (conditional cc) d = s;",notes:"The condition code flag specifies which of the 8 condition codes to check. If it is omitted, 0 is the default."},{id:"movt-d",assemblyName:"movt.d",name:"Floating Point Move on Conditional True Double",description:"Move a double-precision float to another register if a conditional is true",category:i.FLOAT_CONDITIONAL,instructionEncoding:{type:"FCO-Type",opcode:"\u202d010001",format:"10001",cc:"ccc",cond:"01",fs:"sssss",fd:"ddddd",funct:"010001"},usage:"movt.d $fd, $fs, cc",result:"if (conditional cc) d = s;",notes:"The condition code flag specifies which of the 8 condition codes to check. If it is omitted, 0 is the default."},{id:"lwc1",assemblyName:"lwc1",name:"Load Word Coprocessor 1",description:"Load a word from memory to a floating point register",category:i.FLOAT_MEMORY,instructionEncoding:{type:"I-Type",opcode:"\u202d110001",rs:"sssss",rt:"ttttt",imm:"iiiiiiiiiiiiiiii"},usage:"lwc1 $ft, imm($s)",result:"ft = memory[s + imm]",notes:"$ft is a floating point register, $s is a general purpose register."},{id:"ldc1",assemblyName:"ldc1",name:"Load Double Coprocessor 1",description:"Load two words from memory to two floating point registers",category:i.FLOAT_MEMORY,instructionEncoding:{type:"I-Type",opcode:"\u202d110101",rs:"sssss",rt:"ttttt",imm:"iiiiiiiiiiiiiiii"},usage:"ldc1 $ft, imm($s)",result:"ft = memory[s + imm]",notes:"$ft is a floating point register, $s is a general purpose register."},{id:"swc1",assemblyName:"swc1",name:"Store Word Coprocessor 1",description:"Store a word from a floating point register to memory",category:i.FLOAT_MEMORY,instructionEncoding:{type:"I-Type",opcode:"\u202d111001",rs:"sssss",rt:"ttttt",imm:"iiiiiiiiiiiiiiii"},usage:"swc1 $ft, imm($s)",result:"memory[s + imm] = ft",notes:"$ft is a floating point register, $s is a general purpose register."},{id:"sdc1",assemblyName:"sdc1",name:"Store Double Coprocessor 1",description:"Store two words from memory to two floating point registers",category:i.FLOAT_MEMORY,instructionEncoding:{type:"I-Type",opcode:"\u202d111101",rs:"sssss",rt:"ttttt",imm:"iiiiiiiiiiiiiiii"},usage:"sdc1 $ft, imm($s)",result:"memory[s + imm] = ft",notes:"$ft is a floating point register, $s is a general purpose register."},{id:"l-s",assemblyName:"l.s",name:"Load Single",description:"Load a single-precision floating point value from memory to a register",category:i.FLOAT_MEMORY,instructionEncoding:{type:"Pseudo-Instruction",equivalentInstructions:["lui $at, label[31-16]","ori $at, $at, label[15-0]","lwc1 $ft, 0($at)"]},usage:"l.s $ft, label",result:"ft = memory[s + imm]"},{id:"l-d",assemblyName:"l.d",name:"Load Double",description:"Load a double-precision floating point value from memory to a register",category:i.FLOAT_MEMORY,instructionEncoding:{type:"Pseudo-Instruction",equivalentInstructions:["lui $at, label[31-16]","ori $at, $at, label[15-0]","ldc1 $ft, 0($at)"]},usage:"l.d $ft, label",result:"ft = memory[s + imm]"},{id:"s-s",assemblyName:"s.s",name:"Store Single",description:"Store a single-precision floating point value from memory to a register",category:i.FLOAT_MEMORY,instructionEncoding:{type:"Pseudo-Instruction",equivalentInstructions:["lui $at, label[31-16]","ori $at, $at, label[15-0]","swc1 $ft, 0($at)"]},usage:"s.s $ft, label",result:"memory[s + imm] = ft"},{id:"s-d",assemblyName:"s.d",name:"Store Double",description:"Store a double-precision floating point value from memory to a register",category:i.FLOAT_MEMORY,instructionEncoding:{type:"Pseudo-Instruction",equivalentInstructions:["lui $at, label[31-16]","ori $at, $at, label[15-0]","sdc1 $ft, 0($at)"]},usage:"s.d $ft, label",result:"memory[s + imm] = ft"},{id:"mtc0",assemblyName:"mtc0",name:"Move to Coprocessor 0",description:"Move a value from a general-purpose register to a system control coprocessor register",category:i.SYSTEM,instructionEncoding:{type:"COP-Type",opcode:"\u202d010000",funct:"00100",rt:"ttttt",rd:"ddddd",addr:"-----------"},usage:"mtc0 $t, $d",result:"d = t",notes:"The first argument is the register from the main processor, the second is the register from the coprocessor. Unlike most MIPS instructions, the destination of the operation is not listed first."},{id:"mfc0",assemblyName:"mfc0",name:"Move from Coprocessor 0",description:"Move a value from a system control coprocessor register to a general-purpose register",category:i.SYSTEM,instructionEncoding:{type:"COP-Type",opcode:"010000",funct:"00000",rt:"ttttt",rd:"ddddd",addr:"-----------"},usage:"mfc0 $t, $d",result:"t = d",notes:"The first argument is the register from the main processor, the second is the register from the coprocessor."}],$=[{id:"r-type",name:"R-Type",shortName:"R",description:"R-type is named for its focus on maximizing the number of registers. It can specify up to 3 registers. All arithmetic instructions which do not use an immediate are R-Type. Since R-Type instructions do not include immediate values (except the shift amount), space is not as tight as other types. Therefore, they all use the same opcode (0x0), and have a separate funct field to differentiate from each other. Additionally, many R-type instructions do not use all 6 fields.",fields:[{name:"opcode",size:6},{name:"rs",size:5},{name:"rt",size:5},{name:"rd",size:5},{name:"shamt",size:5},{name:"funct",size:6}],encoding:{type:"R-Type",opcode:"000000",rs:"sssss",rt:"ttttt",rd:"ddddd",shamt:"iiiii",funct:"ffffff"}},{id:"i-type",name:"I-Type",shortName:"I",description:"I-type is named for its focus on maximizing the size of the immediate. It can specify up to 2 registers and a 16-bit immediate value. All arithmetic instructions which use an immediate, most branch instructions, and most memory instructions are I-Type. Since I-Type instructions use half their bits for the immediate value, space is tight. Therefore, each I-Type instruction has a unique opcode. Additionally, many instructions must cleverly use the immediate field to fit as much information as possible. For example, branch instructions do not have room to store a 32 bit target address. Therefore, they store the distance from the current location of the branch (divided by 4, since the distance between intructions is always a multiple of 4 bytes).",fields:[{name:"opcode",size:6},{name:"rs",size:5},{name:"rt",size:5},{name:"imm",size:16}],encoding:{type:"I-Type",opcode:"oooooo",rs:"sssss",rt:"ttttt",imm:"iiiiiiiiiiiiiiii"}},{id:"j-type",name:"J-Type",shortName:"J",description:"J-type is named for its focus on maximizing the possible distance of a jump. It can specify a 26-bit address. Like branch instructions, J-Type instructions do not have room to store a 32 bit target address. To 'fit' a 32 bit target into 26 bits, the target address is shifted two bits to the right (instructions are always word-aligned so the rightmost two bits are always 0), and then the upper 4 bits are discarded. When the jump is executed, the address is shifted left 2 bits, and the upper 4 bits of the current PC are added to the stored address to form a complete 32 bit target.",fields:[{name:"opcode",size:6},{name:"addr",size:26}],encoding:{type:"J-Type",opcode:"000010",addr:"aaaaaaaaaaaaaaaaaaaaaaaaaa"}},{id:"ri-type",name:"RI-Type",shortName:"RI",description:"RI-type is named for its use of an extra immediate field called register immediate (regimm) in place of the rt field from the otherwise identical I-Type instruction. It can specify a single register, a 5-bit immediate, and  16-bit immediate. RI-type is mainly used in certain branch instructions which compare a single register with 0. Like R-Type instructions, all RI-type instructions use the same opcode (0x1); the regimm field is used to differentiate RI-type instructions from each other.",fields:[{name:"opcode",size:6},{name:"rs",size:5},{name:"regimm",size:5},{name:"imm",size:16}],encoding:{type:"RI-Type",opcode:"000001",rs:"sssss",regimm:"rrrrr",imm:"iiiiiiiiiiiiiiii"},notes:"Since this instruction type is not used for a large number of instructions, its name and some field names are not consistent across reference sources."},{id:"cop-type",name:"COP-Type",shortName:"COP",description:"COP-type is named for its usage in interaction with coprocessors. The opcode is the same for all coprocessor instructions except for the last two bits, which specify the coproessor (0 - 3).",fields:[{name:"opcode",size:6},{name:"funct",size:5},{name:"rt",size:5},{name:"rd",size:5},{name:"addr",size:11}],encoding:{type:"COP-Type",opcode:"0100oo",funct:"fffff",rt:"ttttt",rd:"ddddd",addr:"aaaaaaaaaaa"}},{id:"ic-type",name:"IC-Type",shortName:"IC",description:"IC-type is used for operations with immediates which test a floating point conditional.",fields:[{name:"opcode",size:6},{name:"format",size:5},{name:"cc",size:2},{name:"cond",size:3},{name:"imm",size:16}],encoding:{type:"IC-Type",opcode:"oooooo",format:"fffff",cc:"ccc",cond:"cc",imm:"iiiiiiiiiiiiiiii"},notes:"Since this instruction type is not used for a large number of instructions, its name and some field names are not consistent across reference sources."},{id:"rc-type",name:"RC-Type",shortName:"RC",description:"RC-type is used for operations on registers which test a floating point conditional.",fields:[{name:"opcode",size:6},{name:"rs",size:5},{name:"cc",size:2},{name:"cond",size:3},{name:"rd",size:5},{name:"shamt",size:5},{name:"funct",size:6}],encoding:{type:"RC-Type",opcode:"oooooo",rs:"sssss",cc:"ccc",cond:"cc",rd:"ddddd",shamt:"sssss",funct:"ffffff"},notes:"Since this instruction type is not used for a large number of instructions, its name and some field names are not consistent across reference sources."},{id:"float",name:"F-Type",shortName:"F",description:"F-type is used for most floating point operations.",fields:[{name:"opcode",size:6},{name:"format",size:5},{name:"ft",size:5},{name:"fs",size:5},{name:"fd",size:5},{name:"function",size:6}],encoding:{type:"F-Type",opcode:"010001",format:"fffff",ft:"ttttt",fs:"sssss",fd:"ddddd",funct:"ffffff"}},{id:"float-conditional-operation",name:"FCO-Type",shortName:"FCO",description:"FCO-type is used for most floating point operations which check a conditional.",fields:[{name:"opcode",size:6},{name:"format",size:5},{name:"cc",size:3},{name:"cond",size:2},{name:"fs",size:5},{name:"fd",size:5},{name:"function",size:6}],encoding:{type:"FCO-Type",opcode:"010001",format:"fffff",cc:"ccc",cond:"cc",fs:"sssss",fd:"ddddd",funct:"ffffff"},notes:"Since this instruction type is not used for a large number of instructions, its name and some field names are not consistent across reference sources."},{id:"float-conditional-test",name:"FCT-Type",shortName:"FCT",description:"FCT-type is used for most floating point operations which set a conditional based on a test.",fields:[{name:"opcode",size:6},{name:"format",size:5},{name:"ft",size:5},{name:"fs",size:5},{name:"cc",size:3},{name:"cond",size:2},{name:"fc",size:2},{name:"function",size:4}],encoding:{type:"FCT-Type",opcode:"010001",format:"fffff",ft:"ttttt",fs:"sssss",cc:"ccc",cond:"cc",fc:"ff",funct:"ffff"},notes:"Since this instruction type is not used for a large number of instructions, its name and some field names are not consistent across reference sources."},{id:"special-two",name:"SPECIAL2-Type",shortName:"SPECIAL2",description:"SPECIAL2-type is used for some instructions added in later versions of the MIPS processor.",fields:[{name:"opcode",size:6},{name:"rs",size:5},{name:"rt",size:5},{name:"rd",size:5},{name:"special",size:5},{name:"funct",size:6}],encoding:{type:"SPECIAL2-Type",opcode:"011100",rs:"sssss",rt:"ttttt",rd:"ddddd",special:"sssss",funct:"ffffff"},notes:"Since this instruction type is not used for a large number of instructions, its name and some field names are not consistent across reference sources."},{id:"pseudo-instruction",name:"Pseudo-Instruction",shortName:"PSEUDO",description:"The MIPS processor is designed to be simple, featuring a relatively small set of machine instructions (instruction which the processor can run). Pseudo-instructions are provided as a convenience for assembly language programmers for common operations that are not implemented in the processor. Unlike other instructions, which are translated by the assembler directly into a corresponding machine instruction, pseudo-instructions do not correspond directly with a single machine instruction. The pseudo-instructions are provided by the assember (the program that translates your assembly language code into a binary program in machine language). Pseudo-instructions are first translated by the assembler into one or more 'real' instructions which perform the desired operation, then these real instructions are translated to equivalent machine language.",fields:[],encoding:{type:"Pseudo-Instruction",equivalentInstructions:[]}}],v=function(e){var t=$.find((function(t){return t.name===e.type}));if(!t)throw new Error("Unknown instruction type");return t},j=[{id:"zero",name:"Zero",numbers:"$0",letterNumbers:"$zero",description:"Constant zero value",preserved:"n/a",notes:"This register always holds a value of zero; attempting to assign other values to it will have no effect."},{id:"at",name:"Assembler Temporary",numbers:"$1",letterNumbers:"$at",description:"Reserved for usage by the assembler",preserved:"n/a",notes:"This register is reserved for use by the assembler (e.g. in expanding pseudo instructions). It should not generally be used."},{id:"values",name:"(Return) Values",numbers:"$2 - $3",letterNumbers:"$v0 - $v1",description:"Values returned from syscalls or function calls",preserved:"n/a"},{id:"arguments",name:"Arguments",numbers:"$4 - $7",letterNumbers:"$a0 - $a3",description:"Arguments for syscalls or function calls",preserved:"yes"},{id:"temporaries-low",name:"Temporaries",numbers:"$8 - $15",letterNumbers:"$t0 - $t7",description:"General use registers whose values will not be preserved across function calls",preserved:"no",notes:"These registers are not saved across function calls. If you call a function, you can not assume they will have the same values once the function call returns. If you are writing a function, you can overwrite the values in any of these registers."},{id:"saves",name:"Saves",numbers:"$16 - $23",letterNumbers:"$s0 - $s7",description:"General use registers whose values will be preserved across function calls",preserved:"yes",notes:"These registers are saved across function calls. If you call a function, you can assume they will have the same values once the function call returns. If you are writing a function, you can not overwrite the values in any of these registers. If you need to use these registers inside a function, you must save their previous values to the stack and restore them before your function returns."},{id:"temporaries-high",name:"Temporaries",numbers:"$24 - $25",letterNumbers:"$t8 - $t9",description:"General use registers whose values will not be preserved across function calls",preserved:"no",notes:"These registers are not saved across function calls. If you call a function, you can not assume they will have the same values once the function call returns. If you are writing a function, you can overwrite the values in any of these registers."},{id:"global-pointer",name:"Global Pointer",numbers:"$28",letterNumbers:"$gp",description:"Used to enable efficient access to global labels",preserved:"yes"},{id:"stack-pointer",name:"Stack Pointer",numbers:"$29",letterNumbers:"$sp",description:"Used to track the current top of the stack",preserved:"yes"},{id:"frame-pointer",name:"Frame Pointer",numbers:"$30",letterNumbers:"$fp",description:"Used to track the location of the current frame",preserved:"yes"},{id:"return-address",name:"Return Address",numbers:"$31",letterNumbers:"$ra",description:"Used to track the location to return to at the end of the current funciton call",preserved:"yes"},{id:"float",name:"Floating Point Registers",numbers:"$0 - $31",letterNumbers:"$f0 \u2013 $f31",description:"A second set of 32 registers used by all floating point instructions.",preserved:"no convention",notes:"Unlike general-purpose registers (the main set of registers), there are no conventions for saving across function calls or special-purpose floating point registers. $f0 does not hold a value of zero like $0 (it can be used like any other floating point register). When working with doubles, each value uses two registers (the first of which must be an even-numbered register). These registers are located in coprocessor 1; data can be tranfered between general purpose registers and floating point registers using the mtc1 and mfc1 instructions."},{id:"hi",name:"HI (Multiplication Result/Division Remainder)",numbers:"n/a",letterNumbers:"n/a",description:"Used to store the upper 32 bits of the result from integer multiplication, or the remainder resultant from integer division",preserved:"n/a",notes:"Cannot be accessed directly. Value can be retrieved with the mfhi instruction, or changed with the mthi instruction."},{id:"lo",name:"LO (Multiplication Result/Division Quotient)",numbers:"n/a",letterNumbers:"n/a",description:"Used to store the lower 32 bits of the result from integer multiplication, or the quotient resultant from integer division",preserved:"n/a",notes:"Cannot be accessed directly. Value can be retrieved with the mflo instruction, or changed with the mtlo instruction."},{id:"pc",name:"Program Counter",numbers:"n/a",letterNumbers:"n/a",description:"Used to store the address of the instruction currently being executed",preserved:"n/a",notes:"Cannot be accessed directly. Jumps and branches change this value to cause execution to move to the desired location."}],O=[{description:"Print an integer to the console",id:"print-integer",inputs:"$a0 = integer to print",name:"Print Integer",number:"1",outputs:"<none>"},{description:"Print a float to the console",id:"print-float",inputs:"$f12 = float to print",name:"Print Float",number:"2",outputs:"<none>"},{description:"Print a double to the console",id:"print-double",inputs:"$f12 = float to print",name:"Print Double",number:"3",outputs:"<none>"},{description:"Print a string to the console",id:"print-string",inputs:"$a0 = address of string to print",name:"Print String",number:"4",outputs:"<none>",notes:"The string must be null terminated."},{description:"Read an integer from the console",id:"read-int",inputs:"<none>",name:"Read Integer",number:"5",outputs:"$v0 = inputted integer"},{description:"Read a float from the console",id:"read-float",inputs:"<none>",name:"Read Float",number:"6",outputs:"$f0 = inputted float"},{description:"Read a double from the console",id:"read-double",inputs:"<none>",name:"Read Double",number:"7",outputs:"$f0 = inputted double"},{description:"Read a string from the console",id:"read-string",inputs:"$a0 = address to store inputted string; $a1 = number of characters to read",name:"Read String",number:"8",outputs:"<none>",notes:"The number of characters to read (specified in $a1) is a maximum; the syscall will keep reading characters until you enter a newline (press enter) or it reaches the maximum. If you press enter before the maximum number of characters has been read, the newline character (ASCII value 10) will be included in the inputted string. The number of characters to read also includes the null terminator. Thus, the maximum number of characters which can be read from the console is actually one less than number specified."},{description:"Allocate memory dynamically",id:"allocate-memory",inputs:"$a0 = number of bytes to allocate",name:"Allocate Memory",number:"9",outputs:"$v0 = address of allocated memory"},{description:"Exit the program",id:"exit",inputs:"<none>",name:"Exit",number:"10",outputs:"<none>"},{description:"Print a character to the console",id:"print-character",inputs:"$a0 = character to print (ascii value)",name:"Print Character",number:"11",outputs:"<none>"},{description:"Read a character from the console",id:"read-character",inputs:"<none>",name:"Read Character",number:"12",outputs:"$v0 = inputted character (ascii value)"}],x=s(40),T=s(41),I=s(0),w=function(e){Object(r.a)(s,e);var t=Object(c.a)(s);function s(e){return Object(o.a)(this,s),t.call(this,e)}return Object(a.a)(s,[{key:"render",value:function(){return Object(I.jsxs)("div",{children:[Object(I.jsx)("h1",{children:this.props.item.name}),this.props.item.items.map((function(e){var t;switch(e.type){case"heading":t=Object(I.jsx)("h4",{className:"text-primary",children:e.text});break;case"paragraph":t=Object(I.jsx)("p",{children:e.text});break;case"code":t=Object(I.jsx)(x.a,{className:"bg-light mb-3",children:Object(I.jsx)(T.a,{children:Object(I.jsx)("pre",{className:"mb-0",children:Object(I.jsx)("code",{children:e.text.replace(/;/g,"\n")})})})})}return t}))]})}}]),s}(d.Component),N=s(46),C=s(42),E=s(43),S=s(44),A=s(45),M=function(e){Object(r.a)(s,e);var t=Object(c.a)(s);function s(e){return Object(o.a)(this,s),t.call(this,e)}return Object(a.a)(s,[{key:"render",value:function(){return Object(I.jsxs)(C.a,{children:[Object(I.jsxs)(E.a,{children:[Object(I.jsx)(S.a,{color:"primary",children:this.props.guide.name}),"\xa0",this.props.guide.description]}),Object(I.jsx)(A.a,{className:"mb-0",children:Object(I.jsx)(l.b,{to:"/guides/".concat(this.props.guide.id),children:"See more"})})]})}}]),s}(d.Component),R=function(e){Object(r.a)(s,e);var t=Object(c.a)(s);function s(e){return Object(o.a)(this,s),t.call(this,e)}return Object(a.a)(s,[{key:"render",value:function(){return Object(I.jsxs)("div",{children:[Object(I.jsx)("h1",{children:"Guides"}),Object(I.jsx)(N.a,{flush:!0,children:this.props.items.map((function(e){return Object(I.jsx)(M,{guide:e},e.id)}))})]})}}]),s}(d.Component),k=s(47),P=s(48),F=s(49),L=s(50),q=function(e){Object(r.a)(s,e);var t=Object(c.a)(s);function s(e){return Object(o.a)(this,s),t.call(this,e)}return Object(a.a)(s,[{key:"render",value:function(){return Object(I.jsxs)("div",{children:[Object(I.jsx)("h1",{children:this.props.item.name}),Object(I.jsx)("h4",{className:"text-primary",children:"Summary"}),Object(I.jsx)("p",{children:this.props.item.description}),Object(I.jsxs)(k.a,{children:[Object(I.jsx)(P.a,{sm:"4",children:Object(I.jsxs)(x.a,{className:"mb-3",children:[Object(I.jsx)(F.a,{children:"Usage"}),Object(I.jsx)(T.a,{children:Object(I.jsx)(L.a,{children:Object(I.jsx)("code",{children:this.props.item.usage})})})]})}),Object(I.jsx)(P.a,{sm:"4",children:Object(I.jsxs)(x.a,{className:"mb-3",children:[Object(I.jsx)(F.a,{children:"Arguements"}),Object(I.jsx)(T.a,{children:Object(I.jsx)(L.a,{children:this.props.item.arguments})})]})}),Object(I.jsx)(P.a,{sm:"4",children:Object(I.jsxs)(x.a,{className:"mb-3",children:[Object(I.jsx)(F.a,{children:"Effect"}),Object(I.jsx)(T.a,{children:Object(I.jsx)(L.a,{children:this.props.item.effect})})]})})]}),this.props.item.notes?Object(I.jsxs)("div",{children:[Object(I.jsx)("h4",{className:"text-primary",children:"Notes"}),Object(I.jsx)("p",{children:this.props.item.notes})]}):null]})}}]),s}(d.Component),z=function(e){Object(r.a)(s,e);var t=Object(c.a)(s);function s(e){return Object(o.a)(this,s),t.call(this,e)}return Object(a.a)(s,[{key:"render",value:function(){return Object(I.jsxs)(C.a,{children:[Object(I.jsxs)(E.a,{children:[Object(I.jsx)(S.a,{color:"primary",children:this.props.assemblerDirective.name}),"\xa0",this.props.assemblerDirective.description]}),Object(I.jsxs)(A.a,{className:"mb-0",children:["Usage: ",Object(I.jsx)("code",{children:this.props.assemblerDirective.usage}),"\xa0\xa0\xa0",Object(I.jsx)(l.b,{to:"/assembler-directives/".concat(this.props.assemblerDirective.id),children:"See more"})]})]})}}]),s}(d.Component),_=function(e){Object(r.a)(s,e);var t=Object(c.a)(s);function s(e){return Object(o.a)(this,s),t.call(this,e)}return Object(a.a)(s,[{key:"render",value:function(){return Object(I.jsxs)("div",{children:[Object(I.jsx)("h1",{children:"Assembler Directives"}),Object(I.jsx)(N.a,{flush:!0,children:this.props.items.map((function(e){return Object(I.jsx)(z,{assemblerDirective:e},e.id)}))})]})}}]),s}(d.Component),D=s(51),B=function(e){Object(r.a)(s,e);var t=Object(c.a)(s);function s(e){return Object(o.a)(this,s),t.call(this,e)}return Object(a.a)(s,[{key:"render",value:function(){if("Pseudo-Instruction"===this.props.enc.type)return Object(I.jsxs)("div",{children:[Object(I.jsx)("h4",{className:"text-primary",children:"Expansion"}),Object(I.jsxs)(x.a,{className:"mb-3",children:[Object(I.jsx)(F.a,{children:"Equivalent Instructions"}),Object(I.jsx)(T.a,{children:Object(I.jsx)("pre",{className:"mb-0",children:Object(I.jsx)("code",{children:this.props.enc.equivalentInstructions.join("\n")})})})]})]});var e,t=this.props.enc;switch(t.type){case"I-Type":e={bits:["31 30 29 28 27 26","25 24 23 22 21","20 19 18 17 16","15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00"],headings:["opcode","rs","rt","imm"],lengths:[6,5,5,16],values:[t.opcode,t.rs,t.rt,t.imm]};break;case"J-Type":e={bits:["31 30 29 28 27 26","25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00"],headings:["opcode","addr"],lengths:[6,26],values:[t.opcode,t.addr]};break;case"R-Type":e={bits:["31 30 29 28 27 26","25 24 23 22 21","20 19 18 17 16","15 14 13 12 11","10 09 08 07 06","05 04 03 02 01 00"],headings:["opcode","rs","rt","rd","shamt","funct"],lengths:[6,5,5,5,5,6],values:[t.opcode,t.rs,t.rt,t.rd,t.shamt,t.funct]};break;case"RI-Type":e={bits:["31 30 29 28 27 26","25 24 23 22 21","20 19 18 17 16","15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00"],headings:["opcode","rs","regimm","imm"],lengths:[6,5,5,16],values:[t.opcode,t.rs,t.regimm,t.imm]};break;case"COP-Type":e={bits:["31 30 29 28 27 26","25 24 23 22 21","20 19 18 17 16","15 14 13 12 11","10 09 08 07 06 05 04 03 02 01 00"],headings:["opcode","funct","rt","rd","addr"],lengths:[6,5,5,5,11],values:[t.opcode,t.funct,t.rt,t.rd,t.addr]};break;case"F-Type":e={bits:["31 30 29 28 27 26","25 24 23 22 21","20 19 18 17 16","15 14 13 12 11","10 09 08 07 06","05 04 03 02 01 00"],headings:["opcode","format","ft","fs","fd","function"],lengths:[6,5,5,5,5,6],values:[t.opcode,t.format,t.ft,t.fs,t.fd,t.funct]};break;case"FCO-Type":e={bits:["31 30 29 28 27 26","25 24 23 22 21","20 19 18","17 16","15 14 13 12 11","10 09 08 07 06","05 04 03 02 01 00"],headings:["opcode","format","cc","cond","fs","fd","funct"],lengths:[6,5,3,2,5,5,6],values:[t.opcode,t.format,t.cc,t.cond,t.fs,t.fd,t.funct]};break;case"FCT-Type":e={bits:["31 30 29 28 27 26","25 24 23 22 21","20 19 18 17 16","15 14 13 12 11","10 09 08","07 06","05 04","03 02 01 00"],headings:["opcode","format","ft","fs","cc","cond","fc","funct"],lengths:[6,5,5,5,3,2,2,4],values:[t.opcode,t.format,t.ft,t.fs,t.cc,t.cond,t.fc,t.funct]};break;case"IC-Type":e={bits:["31 30 29 28 27 26","25 24 23 22 21","20 19 18","17 16","15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00"],headings:["opcode","format","cc","cond","imm"],lengths:[6,5,3,2,16],values:[t.opcode,t.format,t.cc,t.cond,t.imm]};break;case"RC-Type":e={bits:["31 30 29 28 27 26","25 24 23 22 21","20 19 18","17 16","15 14 13 12 11","10 09 08 07 06","05 04 03 02 01 00"],headings:["opcode","rs","cc","cond","rd","shamt","funct"],lengths:[6,5,3,2,5,5,6],values:[t.opcode,t.rs,t.cc,t.cond,t.rd,t.shamt,t.funct]};break;case"SPECIAL2-Type":e={bits:["31 30 29 28 27 26","25 24 23 22 21","20 19 18 17 16","15 14 13 12 11","10 09 08 07 06","05 04 03 02 01 00"],headings:["opcode","rs","rt","rd","special","funct"],lengths:[6,5,5,5,5,6],values:[t.opcode,t.rs,t.rt,t.rd,t.special,t.funct]};break;default:throw new Error("Unknown instruction type")}return Object(I.jsxs)("div",{children:[Object(I.jsx)("h4",{className:"text-primary",children:"Encoding"}),Object(I.jsxs)(D.a,{children:[Object(I.jsx)("thead",{children:Object(I.jsxs)("tr",{children:[Object(I.jsx)("th",{scope:"col"}),e.headings.map((function(e){return Object(I.jsx)("th",{scope:"col",children:e},e)}))]})}),Object(I.jsxs)("tbody",{children:[Object(I.jsxs)("tr",{children:[Object(I.jsx)("th",{scope:"row",children:"Length"},"v"),e.lengths.map((function(t,s){return Object(I.jsx)("td",{children:t},e.headings[s])}))]}),Object(I.jsxs)("tr",{children:[Object(I.jsxs)("th",{scope:"row",children:[Object(I.jsx)("span",{className:"bit-number-offset"}),Object(I.jsx)("span",{className:"bit-number",children:"Bit\xa0Numbers"}),Object(I.jsx)("br",{}),Object(I.jsx)("span",{className:"bit-value",children:"Bit\xa0Values"})]}),e.values.map((function(t,s){return Object(I.jsxs)("td",{className:"text-nowrap font-weight-bold",children:[Object(I.jsx)("span",{className:"bit-number-offset"}),Object(I.jsx)("span",{className:"bit-number text-monospace",children:e.bits[s]}),Object(I.jsx)("br",{}),Object(I.jsx)("span",{className:"bit-value text-monospace",children:t})]},t)}))]})]})]})]})}}]),s}(d.Component),H=function(e){Object(r.a)(s,e);var t=Object(c.a)(s);function s(e){return Object(o.a)(this,s),t.call(this,e)}return Object(a.a)(s,[{key:"render",value:function(){return Object(I.jsxs)("div",{children:[Object(I.jsx)("h1",{children:this.props.item.name}),Object(I.jsx)("h4",{className:"text-primary",children:"Summary"}),Object(I.jsx)("p",{children:this.props.item.description}),Object(I.jsxs)(k.a,{children:[Object(I.jsx)(P.a,{sm:"4",children:Object(I.jsxs)(x.a,{className:"mb-3",children:[Object(I.jsx)(F.a,{children:"Usage"}),Object(I.jsx)(T.a,{children:Object(I.jsx)(L.a,{children:Object(I.jsx)("code",{children:this.props.item.usage})})})]})}),Object(I.jsx)(P.a,{sm:"4",children:Object(I.jsxs)(x.a,{className:"mb-3",children:[Object(I.jsx)(F.a,{children:"Result"}),Object(I.jsx)(T.a,{children:Object(I.jsx)(L.a,{children:this.props.item.result})})]})}),Object(I.jsx)(P.a,{sm:"4",children:Object(I.jsxs)(x.a,{className:"mb-3",children:[Object(I.jsx)(F.a,{children:"Type"}),Object(I.jsx)(T.a,{children:Object(I.jsx)(L.a,{children:Object(I.jsx)(l.b,{className:"link-uncolored",to:"/instruction-types/".concat(this.props.type.id),children:this.props.item.instructionEncoding.type})})})]})})]}),Object(I.jsx)(B,{enc:this.props.item.instructionEncoding}),this.props.item.notes?Object(I.jsxs)("div",{children:[Object(I.jsx)("h4",{className:"text-primary",children:"Notes"}),Object(I.jsx)("p",{children:this.props.item.notes})]}):null]})}}]),s}(d.Component),V=s(18),U=s(52),W=s(53),Y=s(54),G=s(55),J=function(e){Object(r.a)(s,e);var t=Object(c.a)(s);function s(e){return Object(o.a)(this,s),t.call(this,e)}return Object(a.a)(s,[{key:"render",value:function(){return Object(I.jsxs)(C.a,{children:[Object(I.jsxs)(E.a,{children:[Object(I.jsx)(S.a,{color:"primary",children:this.props.instruction.assemblyName}),"\xa0",this.props.instruction.description,"\xa0",Object(I.jsx)(S.a,{color:"secondary",pill:!0,children:this.props.instruction.instructionEncoding.type})]}),Object(I.jsxs)(A.a,{className:"mb-0",children:["Usage: ",Object(I.jsx)("code",{children:this.props.instruction.usage}),"\xa0\xa0\xa0",Object(I.jsx)(l.b,{to:"/instructions/".concat(this.props.instruction.id),children:"See more"})]})]})}}]),s}(d.Component),Q=function(e){Object(r.a)(s,e);var t=Object(c.a)(s);function s(e){var i;return Object(o.a)(this,s),(i=t.call(this,e)).searchFieldRef=void 0,i.searchTextChanged=function(e){var t=e.target.value;t?i.props.history.replace({pathname:i.props.location.pathname,search:"search=".concat(t)}):i.props.history.replace({pathname:i.props.location.pathname,search:""}),i.setState({searchText:e.target.value})},i.state={searchText:""},i.searchFieldRef=d.createRef(),i.componentWillMount=i.componentWillMount.bind(Object(V.a)(i)),i.componentDidMount=i.componentDidMount.bind(Object(V.a)(i)),i}return Object(a.a)(s,[{key:"componentWillMount",value:function(){this.setState({searchText:window.URLSearchParams&&new URLSearchParams(this.props.location.search).get("search")||""})}},{key:"componentDidMount",value:function(){this.searchFieldRef.current&&this.searchFieldRef.current.focus()}},{key:"render",value:function(){var e=this,t=Object.keys(i).map((function(e){return i[e]})),s=this.state.searchText.toLowerCase().trim().split(" ");return Object(I.jsxs)("div",{children:[Object(I.jsx)("h1",{children:"Instructions"}),Object(I.jsx)(U.a,{inline:!0,children:Object(I.jsxs)(W.a,{className:"mb-3",children:[Object(I.jsx)(Y.a,{for:"search",className:"mr-sm-2",children:"Search"}),Object(I.jsx)(G.a,{type:"text",name:"search",id:"filter",autoComplete:"off",placeholder:"name, description, tags...",value:this.state.searchText,onChange:this.searchTextChanged,innerRef:this.searchFieldRef})]})}),function(){if(1!==s.length)return null;var t=e.props.items.filter((function(e){return e.assemblyName===s[0]}));return 0===t.length?null:Object(I.jsxs)("div",{children:[Object(I.jsx)("h3",{className:"text-capitalize",children:"Exact Match"}),Object(I.jsx)(N.a,{flush:!0,children:t.map((function(e){return Object(I.jsx)(J,{instruction:e},e.id)}))})]},"exact-match")}(),t.map((function(t){var i=e.props.items.filter((function(e){return e.category===t&&(1!==s.length||e.assemblyName!==s[0])&&(0===s.length||s.reduce((function(t,s){var i;return t&&(e.assemblyName.toLowerCase().includes(s)||e.description.toLowerCase().includes(s)||!!(null===(i=e.tags)||void 0===i?void 0:i.includes(s)))}),!0))}));return i.length>0?Object(I.jsxs)("div",{children:[Object(I.jsx)("h3",{className:"text-capitalize",children:t}),Object(I.jsx)(N.a,{flush:!0,children:i.map((function(e){return Object(I.jsx)(J,{instruction:e},e.id)}))})]},t):null}))]})}}]),s}(d.Component),Z=Object(u.f)(Q),K=function(e){Object(r.a)(s,e);var t=Object(c.a)(s);function s(e){return Object(o.a)(this,s),t.call(this,e)}return Object(a.a)(s,[{key:"render",value:function(){var e=this;return Object(I.jsxs)("div",{children:[Object(I.jsx)("h1",{children:this.props.item.name}),Object(I.jsx)("h4",{className:"text-primary",children:"Description"}),Object(I.jsx)("p",{children:this.props.item.description}),"Pseudo-Instruction"!==this.props.item.encoding.type?Object(I.jsxs)("div",{children:[Object(I.jsx)("h4",{className:"text-primary",children:"Fields"}),Object(I.jsx)(k.a,{children:this.props.item.fields.map((function(t){return Object(I.jsx)(P.a,{sm:Math.max(Math.floor(12/e.props.item.fields.length),2),children:Object(I.jsxs)(x.a,{className:"mb-3",children:[Object(I.jsx)(F.a,{children:t.name}),Object(I.jsx)(T.a,{children:Object(I.jsxs)(L.a,{children:["Size: ",t.size]})})]})},t.name)}))}),Object(I.jsx)(B,{enc:this.props.item.encoding})]}):null,this.props.item.notes?Object(I.jsxs)("div",{children:[Object(I.jsx)("h4",{className:"text-primary",children:"Notes"}),Object(I.jsx)("p",{children:this.props.item.notes})]}):null]})}}]),s}(d.Component),X=function(e){Object(r.a)(s,e);var t=Object(c.a)(s);function s(e){return Object(o.a)(this,s),t.call(this,e)}return Object(a.a)(s,[{key:"render",value:function(){return Object(I.jsxs)(C.a,{children:[Object(I.jsxs)(E.a,{children:[Object(I.jsx)(S.a,{color:"primary",children:this.props.instructionType.shortName}),"\xa0",this.props.instructionType.name]}),Object(I.jsxs)(A.a,{className:"mb-0",children:["Fields(s): ",Object(I.jsx)("code",{children:this.props.instructionType.fields.map((function(e){return e.name})).join(", ")||"<n/a>"}),"\xa0\xa0\xa0",Object(I.jsx)(l.b,{to:"/instruction-types/".concat(this.props.instructionType.id),children:"See more"})]})]})}}]),s}(d.Component),ee=function(e){Object(r.a)(s,e);var t=Object(c.a)(s);function s(e){return Object(o.a)(this,s),t.call(this,e)}return Object(a.a)(s,[{key:"render",value:function(){return Object(I.jsxs)("div",{children:[Object(I.jsx)("h1",{children:"Instruction Types"}),Object(I.jsx)(N.a,{flush:!0,children:this.props.items.map((function(e){return Object(I.jsx)(X,{instructionType:e},e.id)}))})]})}}]),s}(d.Component),te=function(e){Object(r.a)(s,e);var t=Object(c.a)(s);function s(e){return Object(o.a)(this,s),t.call(this,e)}return Object(a.a)(s,[{key:"render",value:function(){return Object(I.jsxs)("div",{children:[Object(I.jsx)("h1",{children:this.props.item.name}),Object(I.jsx)("h4",{className:"text-primary",children:"Summary"}),Object(I.jsx)("p",{children:this.props.item.description}),Object(I.jsxs)(k.a,{children:[Object(I.jsx)(P.a,{sm:"4",children:Object(I.jsxs)(x.a,{className:"mb-3",children:[Object(I.jsx)(F.a,{children:"Numbers"}),Object(I.jsx)(T.a,{children:Object(I.jsx)(L.a,{children:this.props.item.numbers})})]})}),Object(I.jsx)(P.a,{sm:"4",children:Object(I.jsxs)(x.a,{className:"mb-3",children:[Object(I.jsx)(F.a,{children:"Friendly Names"}),Object(I.jsx)(T.a,{children:Object(I.jsx)(L.a,{children:this.props.item.letterNumbers})})]})}),Object(I.jsx)(P.a,{sm:"4",children:Object(I.jsxs)(x.a,{className:"mb-3",children:[Object(I.jsx)(F.a,{children:"Preserved Accross Function Calls"}),Object(I.jsx)(T.a,{children:Object(I.jsx)(L.a,{children:this.props.item.preserved})})]})})]}),this.props.item.notes?Object(I.jsxs)("div",{children:[Object(I.jsx)("h4",{className:"text-primary",children:"Notes"}),Object(I.jsx)("p",{children:this.props.item.notes})]}):null]})}}]),s}(d.Component),se=function(e){Object(r.a)(s,e);var t=Object(c.a)(s);function s(e){return Object(o.a)(this,s),t.call(this,e)}return Object(a.a)(s,[{key:"render",value:function(){return Object(I.jsxs)(C.a,{children:[Object(I.jsxs)(E.a,{children:[Object(I.jsx)(S.a,{color:"primary",children:this.props.register.numbers}),"\xa0",this.props.register.name]}),Object(I.jsxs)(A.a,{className:"mb-0",children:["Friendly Name(s): ",Object(I.jsx)("code",{children:this.props.register.letterNumbers}),"\xa0\xa0\xa0",Object(I.jsx)(l.b,{to:"/registers/".concat(this.props.register.id),children:"See more"})]})]})}}]),s}(d.Component),ie=function(e){Object(r.a)(s,e);var t=Object(c.a)(s);function s(e){return Object(o.a)(this,s),t.call(this,e)}return Object(a.a)(s,[{key:"render",value:function(){return Object(I.jsxs)("div",{children:[Object(I.jsx)("h1",{children:"Registers"}),Object(I.jsx)(N.a,{flush:!0,children:this.props.items.map((function(e){return Object(I.jsx)(se,{register:e},e.id)}))})]})}}]),s}(d.Component),ne=function(e){Object(r.a)(s,e);var t=Object(c.a)(s);function s(e){return Object(o.a)(this,s),t.call(this,e)}return Object(a.a)(s,[{key:"render",value:function(){return Object(I.jsxs)("div",{children:[Object(I.jsx)("h1",{children:this.props.item.name}),Object(I.jsx)("h4",{className:"text-primary",children:"Summary"}),Object(I.jsx)("p",{children:this.props.item.description}),Object(I.jsxs)(k.a,{children:[Object(I.jsx)(P.a,{sm:"4",children:Object(I.jsxs)(x.a,{className:"mb-3",children:[Object(I.jsx)(F.a,{children:"Code ($v0)"}),Object(I.jsx)(T.a,{children:Object(I.jsx)(L.a,{children:this.props.item.number})})]})}),Object(I.jsx)(P.a,{sm:"4",children:Object(I.jsxs)(x.a,{className:"mb-3",children:[Object(I.jsx)(F.a,{children:"Inputs"}),Object(I.jsx)(T.a,{children:Object(I.jsx)(L.a,{children:this.props.item.inputs})})]})}),Object(I.jsx)(P.a,{sm:"4",children:Object(I.jsxs)(x.a,{className:"mb-3",children:[Object(I.jsx)(F.a,{children:"Outputs"}),Object(I.jsx)(T.a,{children:Object(I.jsx)(L.a,{children:this.props.item.outputs})})]})})]}),this.props.item.notes?Object(I.jsxs)("div",{children:[Object(I.jsx)("h4",{className:"text-primary",children:"Notes"}),Object(I.jsx)("p",{children:this.props.item.notes})]}):null]})}}]),s}(d.Component),oe=function(e){Object(r.a)(s,e);var t=Object(c.a)(s);function s(e){return Object(o.a)(this,s),t.call(this,e)}return Object(a.a)(s,[{key:"render",value:function(){return Object(I.jsxs)(C.a,{children:[Object(I.jsxs)(E.a,{children:[Object(I.jsx)(S.a,{color:"primary",children:this.props.syscall.number}),"\xa0",this.props.syscall.description]}),Object(I.jsxs)(A.a,{className:"mb-0",children:["Input(s): ",Object(I.jsx)("code",{children:this.props.syscall.inputs||"<none>"}),"\xa0 Outputs(s): ",Object(I.jsx)("code",{children:this.props.syscall.outputs||"<none>"}),"\xa0\xa0\xa0",Object(I.jsx)(l.b,{to:"/syscalls/".concat(this.props.syscall.id),children:"See more"})]})]})}}]),s}(d.Component),ae=function(e){Object(r.a)(s,e);var t=Object(c.a)(s);function s(e){return Object(o.a)(this,s),t.call(this,e)}return Object(a.a)(s,[{key:"render",value:function(){return Object(I.jsxs)("div",{children:[Object(I.jsx)("h1",{children:"Syscalls"}),Object(I.jsx)(N.a,{flush:!0,children:this.props.items.map((function(e){return Object(I.jsx)(oe,{syscall:e},e.id)}))})]})}}]),s}(d.Component),re={"instruction-types":{description:"MIPS architecture instruction types",friendlyName:"Instruction Types",getItemComponent:function(e){var t=$.find((function(t){return t.id===e}));return t&&d.createElement(K,{item:t})},getListComponent:function(){return d.createElement(ee,{items:$})}},instructions:{description:"MIPS architecture instructions and QtSpim supported pseudoinstructions",friendlyName:"Instructions",getItemComponent:function(e){var t=b.find((function(t){return t.id===e}));return t&&d.createElement(H,{item:t,type:v(t.instructionEncoding)})},getListComponent:function(){return d.createElement(Z,{items:b})}},syscalls:{description:"QtSpim supported syscalls for console IO, memory allocation, program termination, and other tasks",friendlyName:"Syscalls",getItemComponent:function(e){var t=O.find((function(t){return t.id===e}));return t&&d.createElement(ne,{item:t})},getListComponent:function(){return d.createElement(ae,{items:O})}},"assembler-directives":{description:"QtSpim supported assembler directives for program structure, memory allocation, and more",friendlyName:"Assembler Directives",getItemComponent:function(e){var t=f.find((function(t){return t.id===e}));return t&&d.createElement(q,{item:t})},getListComponent:function(){return d.createElement(_,{items:f})}},registers:{description:"MIPS registers for integers, floats, and system use",friendlyName:"Registers",getItemComponent:function(e){var t=j.find((function(t){return t.id===e}));return t&&d.createElement(te,{item:t})},getListComponent:function(){return d.createElement(ie,{items:j})}},guides:{description:"Other guides for MIPS programming with QtSpim",friendlyName:"Guides",getItemComponent:function(e){var t=y.find((function(t){return t.id===e}));return t&&d.createElement(w,{item:t})},getListComponent:function(){return d.createElement(R,{items:y})}}},ce=function(e){Object(r.a)(s,e);var t=Object(c.a)(s);function s(e){return Object(o.a)(this,s),t.call(this,e)}return Object(a.a)(s,[{key:"render",value:function(){return Object(I.jsx)("div",{children:Object(I.jsx)(h.a,{className:"mb-2",children:Object.keys(re).map((function(e){return Object(I.jsx)(g.a,{children:Object(I.jsx)(l.c,{className:"nav-link",activeClassName:"nav-link link-uncolored",to:"/".concat(e),children:re[e].friendlyName})},e)}))})})}}]),s}(d.Component),de=function(e){Object(r.a)(s,e);var t=Object(c.a)(s);function s(e){return Object(o.a)(this,s),t.call(this,e)}return Object(a.a)(s,[{key:"render",value:function(){return Object(I.jsxs)("div",{children:[Object(I.jsx)("h1",{children:"Topics"}),Object(I.jsx)(k.a,{children:Object.keys(re).map((function(e){return Object(I.jsx)(P.a,{sm:"6",md:"4",lg:"2",children:Object(I.jsxs)(x.a,{className:"mb-3",children:[Object(I.jsxs)(F.a,{children:[Object(I.jsx)(l.b,{className:"link-unstyled",to:"/".concat(e),children:Object(I.jsx)("img",{className:"reference-type-icon",src:"/mips-reference/icons/"+e+".svg",alt:""})}),Object(I.jsx)(l.b,{className:"link-uncolored",to:"/".concat(e),children:re[e].friendlyName})]}),Object(I.jsx)(T.a,{children:Object(I.jsx)(L.a,{children:Object(I.jsx)(l.b,{className:"link-unstyled",to:"/".concat(e),children:re[e].description})})})]},e)},e)}))})]})}}]),s}(d.Component),le=function(e){Object(r.a)(s,e);var t=Object(c.a)(s);function s(){return Object(o.a)(this,s),t.apply(this,arguments)}return Object(a.a)(s,[{key:"render",value:function(){var e=this;return Object(I.jsx)("div",{className:"App",children:Object(I.jsx)(l.a,{basename:"/mips-reference",children:Object(I.jsxs)("div",{children:[Object(I.jsx)(m.a,{className:"bg-light mb-3",fluid:!0,children:Object(I.jsxs)("div",{className:"app-header py-3",children:[Object(I.jsx)(l.c,{className:"link-unstyled",to:"/",children:Object(I.jsxs)("h1",{className:"display-3",children:[Object(I.jsx)("img",{className:"App-logo",src:p,alt:"The site's logo, a drawing of a processor"}),"MIPS Reference"]})}),Object(I.jsx)("p",{className:"lead",children:"MIPS instructions, syscalls, registers, and more"}),Object(I.jsxs)(u.c,{children:[Object(I.jsx)(u.a,{exact:!0,path:"/"}),Object(I.jsx)(u.a,{path:"/",component:ce})]})]})}),Object(I.jsx)(m.a,{fluid:!0,children:Object(I.jsxs)(u.c,{children:[Object(I.jsx)(u.a,{exact:!0,path:"/",component:de}),Object.keys(re).map((function(t){return Object(I.jsx)(u.a,{path:"/".concat(t),render:e.getCategoryRenderer(re[t])},t)}))]})})]})})})}},{key:"getCategoryRenderer",value:function(e){var t=this;return function(s){return Object(I.jsxs)(u.c,{children:[Object(I.jsx)(u.a,{path:"".concat(s.match.path,"/:id"),render:t.getItemRenderer(e)}),Object(I.jsx)(u.a,{path:s.match.path,render:t.getListRenderer(e)})]})}}},{key:"getItemRenderer",value:function(e){return function(t){return e.getItemComponent(t.match.params.id)||Object(I.jsxs)("p",{children:["Item ",t.match.params.id," not found."]})}}},{key:"getListRenderer",value:function(e){return function(t){return e.getListComponent()}}}]),s}(d.Component);n.render(Object(I.jsx)(le,{}),document.getElementById("root"))}},[[39,1,2]]]);
//# sourceMappingURL=main.ce700a4f.chunk.js.map